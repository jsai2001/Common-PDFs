### DevOps: Managing Docker Images with Docker Hub and Azure Container Registry

#### Introduction to Docker
- **Docker** is a platform that enables developers to create, deploy, and run applications within containers.
- Containers allow for easy application portability across different platforms without compatibility issues.
- Prior to Docker, applications needed a separate guest operating system for each environment using virtual machines. Docker resolves this issue by allowing multiple applications to run on a single operating system, reducing resource wastage.

#### Docker Image Creation Process
1. **Dockerfile**: Contains instructions and source code for the application. It is used to build Docker images.
   - The Dockerfile defines steps to build an image, which can then be stored in repositories.
   - Docker images are similar to executable files (.exe) and can be run on any platform.
2. **Building the Image**: Docker reads the instructions from the Dockerfile and creates an image.
3. **Repositories**: The images are stored in repositories, either in public or private registries like Docker Hub or Azure Container Registry.

#### Docker Repositories
- **Docker Hub**: A public repository where Docker images can be stored, maintained, and pulled to run as containers.
- **Azure Container Registry (ACR)**: A private repository offered by Microsoft Azure to store Docker images.

#### Setting Up Docker Hub
1. **Create a Docker Hub Account**: If you don't have one, create an account to start storing Docker images.
2. **Create a Repository**: Similar to GitHub for source code, Docker Hub repositories are used to store Docker images.
   - Example: Create a repository named `Azure Docker` to store Docker images.

#### Integrating Azure DevOps with Docker Hub
1. **Create a Project in Azure DevOps**: The first step is to create a project in Azure DevOps for the Docker image pipeline.
   - Example: Name the project "Azure Docker Hub Integration."
2. **Configure Service Connection**:
   - A **Service Connection** in Azure DevOps allows integration with external services like Docker Hub.
   - Provide the Docker Hub username and password or token in the service connection settings to authorize the connection.
3. **Build Pipeline**:
   - Set up a pipeline in Azure DevOps to automate the process of building and pushing Docker images to Docker Hub.
   - Use a predefined template to create and configure the build steps.

#### Docker Image Deployment Process
1. **Push Images to Docker Hub**: After building the Docker image, the next step is to push it to Docker Hub.
   - You need to configure your Azure DevOps pipeline to push images to Docker Hub after creation.
2. **Run Docker Containers**: Once the image is pushed to Docker Hub, you can pull and run it as a container on any platform.

#### Azure Container Registry (ACR)
- Azure Container Registry is another option for storing Docker images, especially for enterprises using Microsoft services.
- The integration process with Azure DevOps follows a similar pattern as Docker Hub, where the ACR is used to store and manage Docker images.

#### Summary
- Docker simplifies application deployment across different environments by packaging applications into containers.
- Images are created using Dockerfiles, stored in repositories like Docker Hub or ACR, and can be pulled and run as containers on any system.
- Integrating Docker with Azure DevOps allows for automation of the build and deployment processes, making it easier to manage applications across different platforms.

Here’s a summarized version of your DevOps transcript, organized into headings with appropriate explanations and code snippets where necessary:

---

## 1. **Building and Pushing Docker Images to Docker Hub**

When working with Docker, the main objective is to build and push images to a repository like Docker Hub. Here’s a breakdown of how to do it:

### Steps to Build and Push:
1. **Build the Image**: The Dockerfile is used to create a Docker image.
   ```bash
   docker build -t <username>/<repository>:<tag> .
   ```
   Example:
   ```bash
   docker build -t myusername/myrepo:v1 .
   ```

2. **Push the Image**: Once the image is built, it can be pushed to Docker Hub.
   ```bash
   docker push <username>/<repository>:<tag>
   ```
   Example:
   ```bash
   docker push myusername/myrepo:v1
   ```

You can choose to either build and push together or just push an already built image.

### Docker Hub Repository Structure:
- **Username**: Your Docker Hub username.
- **Repository Name**: Name of the Docker repository where the image will be stored.

## 2. **Automating Docker Build and Push Using Pipelines**

Using CI/CD pipelines like Azure DevOps simplifies the building and pushing of Docker images. The YAML script will automate these tasks.

### Example Azure Pipeline YAML:
```yaml
trigger:
  branches:
    include:
      - main

stages:
- stage: Build
  jobs:
  - job: BuildAndPush
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Docker@2
      inputs:
        containerRegistry: 'DockerHub'
        repository: '<username>/<repository>'
        command: 'buildAndPush'
        Dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
        tags: |
          $(Build.BuildId)
```
This YAML file will:
- Trigger the pipeline on changes in the `main` branch.
- Build and push the Docker image using Docker Hub.

---

## 3. **Running Docker Images in Different Environments**

Once the image is pushed to Docker Hub or another container registry, it can be run in various environments, such as Docker or Kubernetes.

### Running Docker Image:
```bash
docker run -d -p 8080:80 <username>/<repository>:<tag>
```
This command runs the Docker container locally, mapping port 8080 of the host to port 80 of the container.

### Running on Kubernetes:
To run the Docker image in Kubernetes, you will need to write a deployment configuration file.
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-app
        image: <username>/<repository>:<tag>
        ports:
        - containerPort: 80
```

---

## 4. **Creating Your Own Pipeline with YAML Script**

Azure DevOps allows you to create custom pipelines by writing your own YAML file, rather than using templates.

### Steps to Create Your Own Pipeline:
1. Write the pipeline YAML script in `azure-pipelines.yml`.
2. Define agents (e.g., `ubuntu-latest`) and stages (e.g., `build`, `push`).
3. Set up the pipeline to trigger on changes in a specific branch.

Example pipeline definition:
```yaml
pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo Hello, world!
  displayName: 'Run a one-line script'
```

### Stages and Jobs:
- **Stage**: A logical grouping of jobs.
- **Job**: A set of steps executed by the agent.

---

## 5. **Using Azure Container Registry (ACR)**

Instead of Docker Hub, you can push images to Azure Container Registry (ACR).

### Steps to Push to ACR:
1. **Create ACR**: Use the Azure portal or CLI to create a new ACR instance.
   ```bash
   az acr create --resource-group myResourceGroup --name myACR --sku Basic
   ```

2. **Build and Push Image**: The pipeline can be modified to push images to ACR:
```yaml
- task: Docker@2
  inputs:
    containerRegistry: 'myACR'
    repository: '<acr_name>.azurecr.io/<repository>'
    command: 'buildAndPush'
    Dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
    tags: |
      $(Build.BuildId)
```

### Authorizing ACR:
You will need to authorize the connection between Azure DevOps and ACR for the pipeline to successfully push the image.

---

## 6. **Using Azure DevOps Service Connections**

To connect Azure DevOps with Azure services like ACR, a service connection must be established. This enables automated access for building, pushing, and managing resources.

### Steps to Create Service Connection:
1. Go to **Project Settings** in Azure DevOps.
2. Select **Service Connections**.
3. Create a new service connection for **Azure Resource Manager** and authorize it with your Azure credentials.

---

## 7. **Triggering Pipelines with Webhooks**

Azure Pipelines can be triggered using webhooks or based on specific events (like code pushes or pull requests).

### Setting Webhook in Docker Hub:
- You can configure webhooks in Docker Hub to trigger the pipeline when a new image is pushed.

---

## 8. **Managing Image Visibility and Security**

Images pushed to Docker Hub or ACR can have visibility settings:
- **Public**: Anyone can pull the image without authentication.
- **Private**: Only authenticated users can access the image.

### Changing Image Visibility:
- For Docker Hub, toggle between public and private in the repository settings.
- For ACR, use Azure RBAC to control access to images.

---

## 9. **Conclusion**

This setup demonstrates how to build and push Docker images to Docker Hub or ACR using Azure DevOps pipelines. The flexibility to run these images in different environments, along with automation through pipelines, enhances the CI/CD workflow.

### DevOps Notes: Docker, Azure, Kubernetes, and Pipelines

#### 1. **Pushing Docker Images to Docker Hub or ACR (Azure Container Registry)**

- Docker is a critical component in the DevOps lifecycle for building and storing images in repositories.
- You can push images to Docker Hub or ACR using **Azure DevOps pipelines**.
- **ACR (Azure Container Registry)**: 
  - Acts as a private repository similar to Docker Hub but within Azure.
  - Images can be stored within your Azure subscription, allowing better integration with Azure services.

#### 2. **Running Docker Images in Containers**

- Once the Docker image is created, it needs to be run in a container.
- Running images on a **single system** (standalone Docker host) isn’t suitable for real-world applications.
- In real-time cases, applications are typically run in a **cluster of systems (nodes)**.
- For clustering, orchestration tools like **Kubernetes** (AKS on Azure) are used.

#### 3. **Creating a Kubernetes Cluster on Azure (AKS)**

- **AKS (Azure Kubernetes Service)** allows running Docker containers on a Kubernetes cluster.
- **Cluster Creation**:
  - Clusters can be created via the **Azure Portal** or the **Azure CLI**. 
  - Using CLI, the steps involve:
    ```bash
    az group create --name <ResourceGroupName> --location <Location>
    az aks create --resource-group <ResourceGroupName> --name <ClusterName> --node-count 2 --enable-addons monitoring --generate-ssh-keys
    ```
  - The first step is creating a **resource group** to organize resources in Azure.
  - Use the above CLI commands to create the Kubernetes cluster (2 worker nodes).
  
#### 4. **Kubernetes Cluster Components**

- **Kubernetes** handles container deployment, scaling, and load balancing.
- Components include:
  - **API Server**: Manages communication between components.
  - **Scheduler**: Ensures containers (called pods) are scheduled on nodes.
  - **Controller**: Maintains desired state (replicas, deployments).
  - **ETCD**: Stores cluster configuration.
  - **Kubelet**: Agent that runs on each node to communicate with the master.
  - **Kube Proxy**: Manages network communication between pods.
  
#### 5. **Connecting ACR with AKS**

- After creating both the AKS cluster and ACR, link ACR to AKS using the command:
  ```bash
  az aks update --resource-group <ResourceGroupName> --name <AKSClusterName> --attach-acr <ACRName>
  ```
- This allows AKS to pull images from the private ACR for container deployments.

#### 6. **Deploying Docker Images on AKS Using YAML Configurations**

- **YAML Configuration**:
  - Deployments on AKS require a **YAML file** that defines how the container should run.
  - Common properties include:
    - **API version**: Specifies the Kubernetes API version used.
    - **Metadata**: Name of the deployment.
    - **Spec**: Number of replicas, container image information, etc.
  - Example of a simple deployment YAML:
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: my-app
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: my-app
      template:
        metadata:
          labels:
            app: my-app
        spec:
          containers:
          - name: my-container
            image: <ACRName>.azurecr.io/<ImageName>:<Tag>
            ports:
            - containerPort: 80
    ```

#### 7. **Azure DevOps Pipelines for AKS Deployments**

- **Build Pipeline**: 
  1. **Fetch the repository**: Clone the project containing the Dockerfile and source code.
  2. **Build Docker image** using Azure DevOps pipeline tasks:
     ```yaml
     - task: Docker@2
       displayName: Build Docker Image
       inputs:
         command: build
         repository: <RepoName>
         Dockerfile: <DockerfilePath>
         tags: |
           $(Build.BuildId)
     ```
  3. **Push Docker image** to ACR:
     ```yaml
     - task: Docker@2
       displayName: Push Image to ACR
       inputs:
         command: push
         repository: <ACRName>.azurecr.io/<ImageName>
         tags: |
           $(Build.BuildId)
     ```

- **Release Pipeline**: 
  1. After the image is pushed to ACR, the next step is running it on AKS.
  2. Use a YAML deployment file to deploy the container on the AKS cluster.
  3. The pipeline will also generate **artifacts** to be used in the deployment.

- **Publish Artifacts**:
  ```yaml
  - task: PublishPipelineArtifact@1
    inputs:
      artifactName: 'deployment-files'
      targetPath: '$(System.DefaultWorkingDirectory)'
  ```

#### 8. **Final Flow of the DevOps Pipeline**

- **Step 1**: Build Docker image from source code.
- **Step 2**: Push Docker image to ACR.
- **Step 3**: Deploy image to AKS using a YAML configuration file.

#### 9. **Kubernetes and Cloud Providers**

- Kubernetes clusters can be run on various cloud platforms:
  - **Azure**: Azure Kubernetes Service (AKS)
  - **AWS**: Elastic Kubernetes Service (EKS)
  - **Google Cloud**: Google Kubernetes Engine (GKE)
  
These platforms allow seamless integration with their cloud ecosystems, making it easier to deploy and manage containers at scale.

#### 10. **Conclusion**

The DevOps workflow involves multiple steps:
- Building Docker images,
- Storing them in a registry (like ACR),
- Deploying the images to a Kubernetes cluster (AKS),
- Automating the entire process with pipelines.

By leveraging tools like Docker, Kubernetes, Azure DevOps, and YAML configuration, a robust and scalable container management system can be established.

# DevOps Notes on Kubernetes Deployment with Azure

## Introduction to Kubernetes and Azure AKS
Kubernetes (K8s) is an open-source platform designed to automate the deployment, scaling, and operation of containerized applications. In a DevOps pipeline, Azure Kubernetes Service (AKS) provides the service for deploying and managing containers in the cloud environment.

### Key Concepts:
- **ACR (Azure Container Registry):** Repository to store Docker images.
- **Kubernetes Cluster:** A collection of nodes used to run containerized applications.
- **YAML File:** Contains the deployment configuration, which instructs Kubernetes on how to deploy the containerized applications.

## Storing and Deploying Docker Images to AKS

### Steps Overview:
1. **Store Docker Images in ACR:**
   - Push Docker images to Azure Container Registry for versioning and centralized access.
   - View and manage the images and their associated tags via ACR.

2. **Deployment Configuration:**
   - Write deployment details in the `azure-aks.yaml` file.
   - This YAML file will have configurations required for deploying into the Kubernetes clusters.

3. **Setting up Deployment Pipeline:**
   - Configure pipelines in Azure DevOps to build and deploy containers.
   - Use **Artifactory** to manage the deployment packages that contain Docker images and the YAML configuration files.
   
   Example of a deployment YAML file:
   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: python-app-deployment
   spec:
     replicas: 3
     selector:
       matchLabels:
         app: python-app
     template:
       metadata:
         labels:
           app: python-app
       spec:
         containers:
         - name: python-container
           image: <ACR-URL>/python-app:latest
           ports:
           - containerPort: 5000
   ```

4. **Releases Pipelines:**
   - Create and manage release pipelines that take the artifacts (e.g., Docker image) and push them to AKS.
   - Define deployment stages and environment details.
   - Example: Deploy to AKS using `kubectl apply`.

## Connecting Azure DevOps to Kubernetes

### Service Connections:
- **KubeCTL** is used as a command-line interface to manage Kubernetes clusters.
- Service connections between Azure DevOps and AKS need to be established using Azure subscriptions.

Example command to connect to Kubernetes:
```bash
az aks get-credentials --resource-group <ResourceGroupName> --name <AKSClusterName>
```

### Pipeline Setup:
- **Artifacts:** Use artifacts built from the CI pipeline as input for the release.
- **Namespace:** Organize the deployment into a specific namespace (default or custom).
  
Example release step:
```bash
kubectl apply -f azure-aks.yaml
```

## Monitoring and Verification

### Verify Nodes and Deployments:
To check the Kubernetes cluster nodes:
```bash
kubectl get nodes
```

To check the deployment:
```bash
kubectl get deployments
```

To describe a deployment:
```bash
kubectl describe deployment python-app-deployment
```

### Check Pods and Services:
To get the running pods:
```bash
kubectl get pods
```

To expose the application as a service and make it accessible externally:
```bash
kubectl expose deployment python-app-deployment --type=LoadBalancer --port=5000
```

## Load Balancing and Exposing Services

### Load Balancer:
AKS provides a load balancer to expose the application externally. It assigns an external IP to access the application via the internet.

To check services:
```bash
kubectl get services
```

To describe the service:
```bash
kubectl describe service python-app-service
```

## Deploying to Azure App Service

Azure App Service provides a platform-as-a-service (PaaS) solution for deploying web applications, APIs, and mobile backends. 

### Deploying Using Azure Pipelines:
1. **Create App Service:**
   - Set up an app service in Azure to host the application.
   
2. **Pipeline for App Service Deployment:**
   - Create a release pipeline that pushes the application to the Azure App Service.

Example deployment task:
```yaml
- task: AzureWebApp@1
  inputs:
    azureSubscription: '<SubscriptionID>'
    appType: 'webApp'
    appName: '<AppServiceName>'
    package: '<PackageLocation>'
```

---

This summarizes the deployment of Dockerized applications to Kubernetes via Azure Kubernetes Service (AKS), along with managing and exposing services.

Here’s a summarized version of your DevOps notes, organized under relevant headings with code snippets included where necessary.

---

# Deploying Web Applications on Azure App Services

## Overview
Azure App Services provides a Platform as a Service (PaaS) that allows you to deploy web applications without managing the underlying infrastructure. This includes features like load balancing, storage, and security.

## Creating a New Project
To begin, create a new project in Azure DevOps for your application. Here’s how you can set it up:

1. **Create a New Pipeline**:
   - Navigate to the Azure DevOps Pipelines section.
   - Click on "New Pipeline" to create a pipeline for your project.

2. **Select the Repository**:
   - Choose where your code is stored (e.g., Azure Repos or GitHub).
   - Select the appropriate branch for deployment.

## Application Framework
When deploying your application, choose the correct framework based on your needs. Options include:

- **ASP.NET**: For .NET applications.
- **Java**: For Java-based applications.

### Code Snippet: Example of an ASP.NET Pipeline
```yaml
# azure-pipelines.yml
trigger:
- main

pool:
  vmImage: 'windows-latest'

steps:
- task: DotNetCoreCLI@2
  displayName: 'Build and publish .NET application'
  inputs:
    command: 'publish'
    projects: '**/*.csproj'
    arguments: '--configuration Release'
```

## Configuring Azure App Service
After selecting your application framework, you need to set up Azure App Services:

1. **Choose the App Type**:
   - Select "Web App on Windows" for .NET applications or the appropriate option for Java applications.

2. **Configure Azure Subscription**:
   - Ensure you have the correct Azure subscription linked to your Azure DevOps project.

### Code Snippet: Sample Azure App Service Configuration
```yaml
- task: AzureWebApp@1
  inputs:
    azureSubscription: 'your-azure-subscription'
    appName: 'your-app-service-name'
    package: '$(System.DefaultWorkingDirectory)/**/*.zip'
```

## Application Registration and Permissions
To manage your application deployment securely, register your application in the Azure portal:

1. **Create App Registration**:
   - Go to Azure Active Directory > App registrations.
   - Click "New registration" to register your application.

2. **Generate Client Secret**:
   - In the registered application, navigate to "Certificates & secrets" to create a new client secret.

3. **Gather Required Information**:
   - Note down the **Application ID** and **Tenant ID** for your deployment.

## Deploying Your Application
Once everything is configured, deploy your application using the Azure DevOps pipeline:

1. **Build the Application**:
   - Use Maven or other build tools appropriate for your application.

2. **Publish Artifacts**:
   - After building, publish the artifacts to Azure App Services.

### Code Snippet: Maven Build Configuration
```yaml
- task: Maven@3
  inputs:
    mavenPomFile: 'pom.xml'
    goals: 'package'
```

3. **Start the Azure App Service**:
   - Deploy the application and ensure the service is started.

## Monitoring and Verification
After deployment, monitor the application status in Azure App Services:

- Check the deployment logs for errors.
- Use the provided URL to access your application.

### Troubleshooting
If you encounter issues (e.g., service not starting), review the Azure logs and ensure all configurations are correct. 

## Conclusion
Using Azure App Services allows you to efficiently deploy and manage applications with minimal overhead. By following the outlined steps, you can deploy various applications using Azure DevOps pipelines.

---

Feel free to adjust any specific code snippets or details as per your actual implementation needs!

### Docker Image Creation and Deployment Process

#### Introduction to Docker
- **Docker** is a platform that allows developers to create, deploy, and run applications in containers.
- Containers help in shipping and deploying applications across multiple platforms with consistency and without compatibility issues.
  
#### Docker Hub and Azure Container Registry
- **Docker Hub**: A public repository to store and share Docker images.
- **Azure Container Registry**: A private repository for Docker images in Azure cloud.

#### Docker File and Docker Images
- **Docker File**: A text file containing instructions to create a Docker image. It typically includes:
  - Source code for the application.
  - Instructions on how to build the Docker image.
- **Docker Image**: A lightweight, standalone, and executable package that includes everything needed to run an application, such as the code, runtime, libraries, and settings.
  
#### Docker Container Architecture
- Unlike virtual machines, Docker containers do not need separate operating systems for each application. 
- Docker optimizes resource utilization by sharing the host OS, which reduces memory and resource wastage.

#### Steps to Deploy Docker Images
1. **Create a Docker File**:
   ```dockerfile
   # Specify the base image
   FROM node:14
   
   # Create an app directory
   WORKDIR /usr/src/app
   
   # Copy the application code
   COPY . .
   
   # Install dependencies
   RUN npm install
   
   # Expose port 8080
   EXPOSE 8080
   
   # Run the application
   CMD [ "node", "app.js" ]
   ```
   
2. **Build the Docker Image**:
   ```bash
   docker build -t <image-name> .
   ```

3. **Push Docker Image to Docker Hub**:
   ```bash
   docker tag <image-name> <docker-hub-username>/<repo-name>:<tag>
   docker push <docker-hub-username>/<repo-name>:<tag>
   ```

4. **Run the Docker Container**:
   ```bash
   docker run -d -p 8080:8080 <image-name>
   ```

#### Integrating Azure DevOps with Docker Hub
1. **Create a Project in Azure DevOps**:
   - Create a project to manage the pipelines and connect to Docker Hub.
   
2. **Configure Docker Service Connection**:
   - Go to **Project Settings > Service Connections**.
   - Create a new service connection for Docker Hub by providing the Docker Hub credentials (username, password, and optional email).

3. **Pipeline Creation**:
   - Define the pipeline configuration in `azure-pipelines.yml`:
     ```yaml
     trigger:
       - master
     pool:
       vmImage: 'ubuntu-latest'
     steps:
     - task: Docker@2
       inputs:
         containerRegistry: 'Docker Hub Connection'
         repository: '<docker-hub-username>/<repo-name>'
         command: 'buildAndPush'
         dockerfile: '**/Dockerfile'
         tags: |
           $(Build.BuildId)
     ```

4. **Import Repository from GitHub**:
   - Import your code repository from GitHub into Azure DevOps.
   - Ensure the repository contains both the **source code** and **Docker file**.

5. **Deploy the Application**:
   - After the image is built and pushed to Docker Hub, pull the image and run the container.

#### Key Concepts
- **Service Connections**: Secure integration between Azure DevOps and external services such as Docker Hub.
- **Dockerfile Instructions**:
  - `FROM`: Defines the base image.
  - `WORKDIR`: Sets the working directory.
  - `COPY`: Copies files into the image.
  - `RUN`: Executes commands inside the image.
  - `EXPOSE`: Exposes the application to specific ports.
  - `CMD`: Defines the default command to run the application.

This summarizes the process of creating, pushing, and deploying Docker images using Azure DevOps and Docker Hub integration.

### DevOps Pipeline Notes

**Overview:**
This guide focuses on creating a DevOps pipeline using Azure DevOps and Docker for building, pushing, and managing container images. The setup includes automating CI/CD workflows to build Docker images and push them to Docker Hub or Azure Container Registry (ACR). Here's a structured breakdown:

---

### 1. **Build and Push Docker Image to Docker Hub**

- **Command Overview:**
    - You can either build and push or simply push the Docker image.
    - Refer to the `Dockerfile` to create an image.

- **Steps to Build and Push:**
    - Save the pipeline configuration and run it.
    - The image will be built based on the source code and pushed to Docker Hub.
  
- **Verifying Docker Push:**
    - Check Docker Hub to ensure the image is pushed.
  
**Example Command:**
```bash
docker build -t <username>/<repository>:<tag> .
docker push <username>/<repository>:<tag>
```

---

### 2. **Running Docker Image:**

- You can run the Docker image on any platform or environment like Kubernetes or directly as a Docker container.

**Example Command:**
```bash
docker run -d -p 80:80 <username>/<repository>:<tag>
```

---

### 3. **Creating and Managing Pipelines in Azure DevOps**

- **Pipeline Configuration:**
    - Pipelines can be configured using `YAML` scripts.
    - You can also use editors for configuring the pipeline manually.

- **YAML Script Example:**
    ```yaml
    trigger:
      branches:
        include:
          - main
    
    stages:
    - stage: Build
      jobs:
      - job: BuildJob
        pool:
          vmImage: 'ubuntu-latest'
        steps:
        - script: docker build -t $(Build.Repository.Name):$(Build.BuildId) .
    - stage: Push
      jobs:
      - job: PushJob
        pool:
          vmImage: 'ubuntu-latest'
        steps:
        - script: docker push $(Build.Repository.Name):$(Build.BuildId)
    ```

---

### 4. **Setting Up Azure Pipelines for Docker Hub:**

- **Create the pipeline in Azure DevOps.**
    - The file name should be `azure-pipelines.yml` or any valid YAML configuration.
    - Choose your agent (e.g., `Ubuntu-latest` or `Windows`).
    - Define stages like Build and Push.

**Pipeline Example:**
```yaml
pool:
  vmImage: 'ubuntu-latest'

steps:
- task: Docker@2
  inputs:
    containerRegistry: 'DockerHub'
    repository: 'my-repo/my-app'
    command: 'buildAndPush'
    Dockerfile: '**/Dockerfile'
    tags: 'latest'
```

---

### 5. **Using Azure Container Registry (ACR):**

- **Why Use ACR?**
    - Azure provides its own container registry (ACR) to store Docker images instead of relying on third-party services like Docker Hub.

- **Steps to Push Image to ACR:**
    1. Create an ACR in the Azure portal.
    2. Set up the ACR in Azure DevOps as a service connection.
    3. Use the Azure CLI or Azure DevOps pipeline to push images to ACR.

**Command to Push to ACR:**
```bash
az acr login --name <acrName>
docker tag <image> <acrName>.azurecr.io/<repository>:<tag>
docker push <acrName>.azurecr.io/<repository>:<tag>
```

---

### 6. **Authorizing Azure DevOps with ACR:**

- **Authorization Steps:**
    - Azure DevOps needs authorization to push to ACR.
    - Provide your Azure subscription details and authorize via service connections.

- **Example Service Connection Authorization:**
    - Go to Azure DevOps > Project Settings > Service Connections.
    - Select Azure Resource Manager and authorize your account to allow access.

---

### 7. **CI/CD with Azure DevOps and Docker:**

- **Triggering Jobs:**
    - You can set triggers to automate builds based on Git commits or scheduled times.

- **Adding Multiple Stages:**
    - You can add more stages like testing, linting, and security scans.
    - Each stage can be named for clarity (e.g., `Build`, `Push`, `Test`).

---

### 8. **Making Docker Repositories Public or Private:**

- You can change the visibility of your Docker repository at any time (from public to private or vice versa).

---

### 9. **Using Webhooks for Automation:**

- You can use webhooks to automate actions like triggering builds based on specific events, similar to what’s done in Jenkins or GitLab CI.

**Webhook Example:**
```bash
curl -X POST <webhook_url>
```

---

These notes capture key steps in managing Docker images using Azure DevOps and Docker Hub or Azure Container Registry, covering both automatic and manual configurations.

### DevOps Notes on Image Creation and Container Deployment in Azure AKS

#### 1. **Building and Pushing Docker Images using Azure DevOps Pipelines**
- To create and push Docker images to a repository, Azure DevOps pipelines can be used.
- ACR (Azure Container Registry) serves as a repository, much like Docker Hub, but within Azure's subscription service.

    **Key Command:**
    ```bash
    az acr build --registry <acr-name> --image <image-name> .
    ```
    This command pushes the image to ACR after building it.

#### 2. **Running Containers in Azure Kubernetes Service (AKS)**
- After building the Docker image, the next step is running it in a container.
- AKS (Azure Kubernetes Service) is used to run containers in a cluster across multiple nodes, offering scalability.

    **Steps:**
    - First, create a cluster using AKS.
    - Then, deploy the image to the cluster using Kubernetes.

    **Command to Create Cluster:**
    ```bash
    az aks create --resource-group <resource-group-name> --name <cluster-name> --node-count 2 --enable-addons monitoring --generate-ssh-keys
    ```

    - A resource group is essential for AKS. Create it using:
    ```bash
    az group create --name <resource-group-name> --location <location>
    ```

#### 3. **Connecting ACR to AKS**
- Link ACR to AKS so the cluster can pull images directly from the registry.

    **Command to Attach ACR to AKS:**
    ```bash
    az aks update -n <aks-cluster-name> -g <resource-group-name> --attach-acr <acr-name>
    ```

#### 4. **Kubernetes Deployment via YAML**
- Kubernetes deployment is managed through YAML configuration files.

    **Sample YAML Configuration:**
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: <deployment-name>
    spec:
      replicas: 3
      selector:
        matchLabels:
          app: <app-name>
      template:
        metadata:
          labels:
            app: <app-name>
        spec:
          containers:
          - name: <container-name>
            image: <acr-name>.azurecr.io/<image-name>:<tag>
            ports:
            - containerPort: 80
    ```

#### 5. **Deploying the YAML File**
- After preparing the YAML file, you can deploy it using the `kubectl` command.

    **Command to Deploy YAML:**
    ```bash
    kubectl apply -f <yaml-file-path>
    ```

#### 6. **Pipeline Configuration for Image Build and Deploy**
- Configure Azure Pipelines to:
  - Build the image.
  - Push the image to ACR.
  - Run the image on AKS using the YAML deployment.

    **Sample Azure Pipeline YAML:**
    ```yaml
    trigger:
    - master

    pool:
      vmImage: 'ubuntu-latest'

    steps:
    - task: Docker@2
      inputs:
        containerRegistry: '<acr-service-connection>'
        repository: '<image-repo>'
        command: 'buildAndPush'
        Dockerfile: '**/Dockerfile'
        tags: |
          $(Build.BuildId)

    - task: Kubernetes@1
      inputs:
        connectionType: 'Azure Resource Manager'
        azureSubscription: '<azure-subscription>'
        azureResourceGroup: '<resource-group>'
        kubernetesCluster: '<aks-cluster>'
        namespace: 'default'
        command: 'apply'
        useConfigurationFile: true
        configuration: '<path-to-deployment-file>'
    ```

#### 7. **Monitoring and Verifying Deployment**
- Use the following commands to verify that the pods and services are running as expected:

    **Check Pods:**
    ```bash
    kubectl get pods
    ```

    **Check Services:**
    ```bash
    kubectl get services
    ```

This covers the process of building Docker images, pushing them to ACR, creating Kubernetes clusters, deploying YAML files, and verifying the deployment.

### DevOps Deployment Process Using Kubernetes and Azure

#### 1. **Image Creation and Artifact Storage**
- Create Docker images and store them in Azure Container Registry (ACR).
- View the stored images by navigating to the repositories and checking image tags.
- Images are now ready for deployment.

#### 2. **Deployment to Kubernetes Cluster**
- Use the YAML file to configure deployments. The YAML file should contain deployment information for Kubernetes clusters.
- Example file name for Azure Kubernetes Service (AKS) deployment: `azure-aks.yaml`.

#### 3. **Deploying Artifacts**
- After building the artifact, create a release pipeline to push the artifacts to the Kubernetes cluster.
- Select **AKS** as the deployment target.
  
#### 4. **Creating the Release Pipeline**
- Go to **Releases** in Azure DevOps and create a new pipeline.
- Configure the pipeline to push artifacts to the Kubernetes cluster (AKS).
- Add the artifact generated in the previous step.
- The Kubernetes deployment file (YAML) should be referenced in the pipeline.

#### 5. **Configuring Kubernetes Jobs**
- The deployment jobs will be configured using `kubectl` commands to manage the Kubernetes clusters.
- Example commands:
  ```bash
  kubectl apply -f azure-aks.yaml
  kubectl get nodes
  kubectl get deployments
  ```
- Ensure service connections between Azure DevOps and the Kubernetes cluster are set up correctly. This allows deployment through the CI/CD pipeline.

#### 6. **Namespace and Cluster Authorization**
- Use namespaces to organize different projects or teams working on the same cluster.
- Example configuration for namespace in Kubernetes:
  ```bash
  kubectl apply -f azure-aks.yaml --namespace=default
  ```
- Authorize Azure subscriptions and create necessary service connections between Azure DevOps and the AKS.

#### 7. **Deployment Verification**
- Use `kubectl` commands to check the status of the nodes, deployments, and services after deployment.
  ```bash
  kubectl get deployments
  kubectl get services
  ```
- Check for the external IP address assigned by the Load Balancer for accessing the service.

#### 8. **Scaling and Managing Replicas**
- Define the number of replicas in the Kubernetes deployment YAML file.
- Example of scaling the number of replicas:
  ```yaml
  replicas: 3
  ```
- Verify the running pods based on the replicas using:
  ```bash
  kubectl get pods
  ```

#### 9. **Exposing the Service**
- To expose the Kubernetes service, check the external IP and the assigned port using:
  ```bash
  kubectl get svc
  ```
- Ensure that the application is accessible via the assigned external IP and port.

#### 10. **Complete Deployment Pipeline**
- The pipeline consists of two major steps:
  1. **Build Step**: Create Docker images and store them.
  2. **Release Step**: Deploy the stored artifacts to the Kubernetes clusters using the configured YAML file.

### Sample Commands for Reference:
- Apply the YAML file:
  ```bash
  kubectl apply -f azure-aks.yaml
  ```
- Check running nodes:
  ```bash
  kubectl get nodes
  ```
- Check deployments:
  ```bash
  kubectl get deployments
  ```
- Describe a specific deployment:
  ```bash
  kubectl describe deployment <deployment_name>
  ```
- Check running services:
  ```bash
  kubectl get services
  ```
- Expose the service with a specific port:
  ```bash
  kubectl expose deployment <deployment_name> --port=5000
  ```

This process outlines the steps to deploy applications on Kubernetes using Azure DevOps, managing artifacts, and configuring deployments with YAML files.

### DevOps Notes: Deploying Applications Using Azure App Services

---

#### 1. **Infrastructure & Platform Overview**
   - Azure provides **Platform as a Service (PaaS)** capabilities, including:
     - Servers
     - Load balancers
     - Storage
     - Security options
   - These resources can be leveraged for creating and managing applications.

---

#### 2. **Pipeline Setup for Application Deployment**
   - You can create a **new project** using Azure pipelines.
   - **Code Push**:
     - Code can be pushed from Azure Repos or GitHub to the pipeline.
   - **Language & Framework Selection**:
     - Choose the appropriate framework (e.g., ASP.NET, Java) based on the application.
     - Example:
       ```bash
       # Choose ASP.NET for .NET applications or switch to Java if needed.
       framework: ASP.NET
       ```

---

#### 3. **Selecting App Service for Deployment**
   - To deploy, go to **Azure App Services** and choose the platform (e.g., ASP.NET or Java).
   - Example:
     ```bash
     # Select App Service for ASP.NET
     appService: Azure Web App for ASP.NET
     ```
   - This will deploy the code onto the selected service.

---

#### 4. **Managing Azure Subscriptions**
   - To deploy, you need to manage your Azure subscription:
     - **Azure Subscription Management**:
       - Get the **Application ID**, **Service Principal ID**, and **Subscription ID** from Azure.
       - You can generate a new secret for authentication.

     Example of subscription details:
     ```bash
     applicationID: <your-app-id>
     servicePrincipalID: <your-service-principal-id>
     subscriptionID: <your-subscription-id>
     ```

---

#### 5. **Configuring Pipeline for ASP.NET**
   - The deployment pipeline requires configuration:
     - Use **NuGet Package Manager** for ASP.NET projects.
     - Deploy the code onto **App Services**.

     Example for ASP.NET Deployment:
     ```yaml
     trigger:
       branches:
         include:
           - main

     pool:
       vmImage: 'windows-latest'

     steps:
       - task: UseNuGet@5
       - task: AzureWebApp@1
         inputs:
           azureSubscription: <azure-subscription-id>
           appType: 'webApp'
           appName: '<your-app-name>'
           package: '$(Build.ArtifactStagingDirectory)/**/*.zip'
     ```

---

#### 6. **Switching to Java (Optional)**
   - If deploying a Java application, switch the configuration:
     - Use **Maven** to build the Java application.

     Example for Java Deployment:
     ```yaml
     - task: Maven@3
       inputs:
         mavenPomFile: 'pom.xml'
         goals: 'package'
     ```

   - For deployment:
     ```yaml
     - task: AzureWebApp@1
       inputs:
         azureSubscription: '<azure-subscription-id>'
         appType: 'webApp'
         appName: '<your-app-name>'
         package: '$(Build.ArtifactStagingDirectory)/**/*.war'
     ```

---

#### 7. **Deploying Application Using Azure Pipeline**
   - **Deployment Process**:
     1. Build the application (ASP.NET or Java).
     2. Publish artifacts.
     3. Deploy the application to the Azure App Service.
     4. Start the Azure App Service after deployment.

     Example for stopping and starting the App Service:
     ```bash
     az webapp stop --name <app-name> --resource-group <resource-group>
     az webapp start --name <app-name> --resource-group <resource-group>
     ```

---

#### 8. **Handling Errors**
   - If there are any issues during deployment (e.g., services stopped), handle the errors by checking pipeline logs and restarting services.

     ```bash
     # Check pipeline status and restart services if needed
     az webapp start --name <app-name> --resource-group <resource-group>
     ```

---

#### 9. **Artifact Management**
   - Ensure the generated artifacts (e.g., WAR files for Java) are published and deployed correctly.

     ```bash
     # Example artifact deployment
     $(Build.ArtifactStagingDirectory)/**/*.war
     ```

---

#### 10. **Customizing for Different Environments**
   - Azure Pipelines allow you to customize deployments based on different environments and languages.

   - Example customization:
     ```yaml
     # Example for switching between different frameworks
     appType: 'webApp'  # Change based on your requirement (e.g., Java, .NET)
     ```

---

#### Summary
Azure provides a comprehensive platform for deploying various applications using its PaaS model. Using Azure Pipelines, you can easily push code, manage subscriptions, and deploy applications in different frameworks like ASP.NET and Java. Adjusting configurations based on the language and environment is key for a successful deployment process.