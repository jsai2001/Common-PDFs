### **Azure Certification Overview**

#### **Responsibilities:**
- **Participate in all phases of development:**
  - Requirements gathering
  - Design
  - Development
  - Deployment
  - Security
  - Maintenance
  - Performance tuning
  - Monitoring

#### **Proficiency in Azure:**
- **SDK (Software Development Kit):**
  ```powershell
  # Example of using Azure SDK for Python
  from azure.identity import DefaultAzureCredential
  from azure.mgmt.resource import ResourceManagementClient

  credential = DefaultAzureCredential()
  subscription_id = "your_subscription_id"
  resource_client = ResourceManagementClient(credential, subscription_id)
  ```

- **Data Storage Options:**
  - Azure Blob Storage
  - Azure Table Storage
  - Azure Queue Storage
  - Azure Files

- **Data Connections:**
  - SQL Database
  - Cosmos DB
  - Data Factory

- **APIs:**
  ```csharp
  // Example of calling Azure API using C#
  using Microsoft.Azure.Management.ResourceManager.Fluent;
  using Microsoft.Azure.Management.ResourceManager.Fluent.Core;

  var azure = Azure.Authenticate(credentials).WithSubscription("your_subscription_id");
  var resourceGroup = azure.ResourceGroups.GetByName("myResourceGroup");
  ```

- **App Authentication and Authorization:**
  - Azure Active Directory (Azure AD)
  - Managed Identities

- **Compute and Container Deployment:**
  - Virtual Machines
  - App Services
  - Azure Kubernetes Service (AKS)
  - Azure Container Instances

- **Debugging:**
  - Application Insights
  - Log Analytics

#### **Partnership With:**
- Cloud Solution Architects
- Database Administrators (DBAs)
- DevOps Engineers
- Infrastructure Administrators
- Other Stakeholders

#### **Required Experience and Skills:**
- **At least two years of programming experience.**
- **Proficient in Azure SDKs:**
  - Familiarity with languages like Python, C#, Java, etc., in context with Azure.

- **Tools Proficiency:**
  ```bash
  # Azure CLI command example
  az login
  az group create --name MyResourceGroup --location "East US"
  ```

#### **Skills Measured:**
1. **Develop Azure Compute Solutions**
   - Implement virtual machines, scale sets, app services, containers.

2. **Develop for Azure Storage**
   - Use Azure Blob, Queue, Table, and File storage.

3. **Implement Azure Security**
   - Secure resources with Azure AD, manage keys, secrets, and manage security policies.

4. **Monitor, Troubleshoot, and Optimize Azure Solutions**
   - Use Azure Monitor, Application Insights for performance monitoring.

5. **Connect to and Consume Azure Services and Third-Party Services**
   - Integrate with other Azure services, external APIs, and services.

These notes should give you a solid foundation for understanding what is expected from you in the Azure certification exam. Make sure to practice with the tools and SDKs, as practical experience will be crucial.

### **AZ-204: Implement Azure App Service Web Apps**

#### **Overview of Azure App Service:**
- **Functions of Azure App Service:**
  - Hosting web applications, REST APIs, and mobile back ends.
  - Supports multiple languages like .NET, .NET Core, Java, Ruby, Node.js, PHP, or Python.

#### **Key Operations:**

- **Creating and Updating an App:**
  ```azurecli
  # Create a new web app
  az webapp up --sku F1 --name <app-name> --resource-group <resource-group-name>

  # Update an existing web app
  az webapp config appsettings set --resource-group <resource-group-name> --name <app-name> --settings "key=value"
  ```

- **Authentication and Authorization:**
  - Configure Authentication/Authorization in App Service to secure your app.
  - Use Azure AD, Google, Facebook, Twitter, or Microsoft Account for authentication.

- **App Settings:**
  - Manage configuration settings outside of your deployment package.
  ```bash
  # Add app settings
  az webapp config appsettings set --resource-group <resource-group-name> --name <app-name> --settings "Setting1=Value1" "Setting2=Value2"
  ```

- **Scaling Apps:**
  - Scale-up (change the pricing tier for more resources) or scale-out (add more instances).
  ```azurecli
  # Scale up to a different tier
  az appservice plan update --resource-group <resource-group-name> --name <app-service-plan-name> --sku P1V2

  # Scale out (adjust instance count)
  az appservice plan update --resource-group <resource-group-name> --name <app-service-plan-name> --number-of-workers 5
  ```

- **Deployment Slots:**
  - Slots allow you to deploy different versions of your app for testing before making them live.
  ```azurecli
  # Create a deployment slot
  az webapp deployment slot create --name <app-name> --resource-group <resource-group-name> --slot staging

  # Swap slots
  az webapp deployment slot swap --name <app-name> --resource-group <resource-group-name> --slot staging --target-slot production
  ```

#### **Prerequisites:**
- **Experience:**
  - At least one year of experience developing scalable solutions through all phases of software development.

- **Azure Knowledge:**
  - Basic understanding of Azure, cloud concepts, Azure services, and operations via the Azure portal.

- **Recommended Training:**
  - If new to Azure, complete the **AZ-900: Azure Fundamentals** course to get foundational knowledge.

#### **Additional Tips:**
- **Practice with Azure App Service:**
  - Use the Azure portal, Azure CLI, and ARM templates to get hands-on experience.
  - Experiment with different authentication providers and understand how they integrate with your applications.
  
- **Understand Deployment:**
  - Learn how continuous deployment works with Azure DevOps, GitHub actions, or other CI/CD tools.

- **Monitor and Troubleshoot:**
  - Get familiar with Azure Monitor and Application Insights for monitoring your web apps' performance and diagnosing issues.

By mastering these concepts and practices, you'll be well-prepared for the AZ-204 exam section on implementing Azure App Service web apps.

### **Introduction to Azure App Service Evaluation**

#### **Azure App Service Key Components and Value:**

- **Platform as a Service (PaaS):** Azure App Service provides a managed environment for hosting web applications, REST APIs, and mobile backends. 

- **Supported Languages:** .NET, .NET Core, Java, Ruby, Node.js, PHP, Python.

- **Built-in Features:**
  - Automatic scaling, load balancing, and high availability.
  - **Continuous Deployment:** Integration with source control systems like GitHub, Azure DevOps.

- **Value Proposition:**
  - **Simplicity:** Easy to deploy and manage web applications without worrying about infrastructure.
  - **Cost-Effective:** Pay only for what you use with various pricing tiers.
  - **Security:** SSL/TLS encryption, authentication/authorization capabilities.

#### **Authentication and Authorization in Azure App Service:**

- **Authentication/Authorization Middleware:**
  - Azure App Service can handle user authentication for your app.
  - Supports authentication providers like Azure AD, Google, Twitter, Microsoft Account.

- **Implementation:**
  - **App Settings:**
    ```bash
    # Enable Authentication/Authorization for an app
    az webapp auth update --resource-group <resource-group-name> --name <app-name> --enabled true --action AllowAnonymous
    ```

#### **Controlling Traffic to Your Web App:**

- **Inbound Traffic Control:**
  - **IP Restrictions:** Allow or block traffic from specific IP addresses.
    ```bash
    # Add an IP restriction
    az webapp config access-restriction add --resource-group <resource-group-name> --name <app-name> --rule-name "AllowSpecificIP" --action Allow --ip-address <ip-address>
    ```

  - **Service Endpoints:** Secure access to Azure services from your web app.

- **Outbound Traffic Control:**
  - **Hybrid Connections:** Connect to on-premises systems securely.
  - **Virtual Network Integration:** Route outbound traffic through a VNet.

#### **Deploying an App to App Service Using Azure CLI:**

- **Deployment Steps:**

  1. **Prepare Your App:**
     - Ensure your app is compatible with App Service (check runtime support).

  2. **Create App Service Plan and Web App:**
     ```bash
     # Create an App Service Plan
     az appservice plan create --name myAppServicePlan --resource-group <resource-group-name> --sku FREE

     # Create a new web app
     az webapp create --resource-group <resource-group-name> --plan myAppServicePlan --name <app-name>
     ```

  3. **Deploy using Azure CLI:**
     ```bash
     # Deploy from a local folder
     az webapp up --name <app-name> --resource-group <resource-group-name> --sku F1
     ```

     - **Git Deployment:**
       ```bash
       # Configure deployment from a Git repository
       az webapp deployment source config --name <app-name> --resource-group <resource-group-name> --repo-url <git-repo-url> --branch master --manual-integration
       ```

#### **Learning Objectives Recap:**

- **Describe:** Understand and articulate the features and benefits of Azure App Service.
- **Explain:** Gain insights into how authentication works within App Service.
- **Identify:** Know the tools and settings for managing network traffic.
- **Deploy:** Practice deploying an app using Azure CLI for real-world applicability.

These notes will help you present a thorough evaluation of Azure App Service to your company, showcasing its capabilities, security features, and deployment processes.

### **Azure App Service Overview**

- **Purpose:** 
  - HTTP-based service for hosting web applications, REST APIs, and mobile backends.
  - Supports development in various programming languages and frameworks.

- **OS Support:**
  - Runs on Windows and Linux environments.

#### **Key Features:**

- **Auto-Scale Support:**
  - **Scaling Up/Down:** Adjust resources like cores and RAM on the host machine.
  - **Scaling Out/In:** Increase/decrease the number of instances running your app.

- **Container Support:**
  - **Deployment:** Deploy containerized apps on both Windows and Linux.
  - **Sources:** Use containers from Azure Container Registry or Docker Hub.
  - **Multi-container Apps:** Supports complex applications with multiple containers.
  - **Orchestration:** Use Docker Compose for managing container instances.

- **Continuous Integration/Deployment (CI/CD):**
  - **Integration Options:** Azure DevOps, GitHub, Bitbucket, FTP, or local Git.
  - **Process:** Auto-syncs code changes to the web app.
  - **Container CI/CD:** Support for containerized deployments.

- **Deployment Slots:**
  - **Functionality:** Use separate slots for staging deployments (Standard tier or above).
  - **Swapping:** Easily swap content and configurations between slots, including production.

#### **App Service on Linux:**

- **Native Support:** Host apps directly on Linux for languages like Node.js, Java, PHP, Python, .NET, Ruby.
- **Custom Containers:** Option to deploy your custom Docker containers.
- **Runtime Updates:** Languages and frameworks are frequently updated.
- **Check Supported Runtimes:**
  ```bash
  az webapp list-runtimes --os-type linux
  ```

#### **Limitations of App Service on Linux:**

- **Pricing:** Not available in the Shared pricing tier.
- **Portal Features:** Only Linux-compatible features are displayed in the Azure portal.
- **Storage:**
  - Built-in images use Azure Storage for content, which might have higher and variable latency.
  - Consider custom containers for apps needing high read-only access to content files for better performance.

#### **Conclusion:**

Azure App Service offers robust features for web app hosting, from scalability to containerization and seamless CI/CD. While there are some limitations, particularly with Linux-based services, the platform provides versatile options for developers to deploy applications efficiently. Remember to consider these limitations when choosing your deployment strategy for Linux-based applications to ensure you select the appropriate tier and deployment method for your needs.

### **Azure App Service Plans**

#### **Overview:**

- **Purpose:** An App Service plan defines compute resources for web apps to run on.
- **Shared Resources:** Multiple apps can run on the same set of compute resources.

#### **Components of an App Service Plan:**

- **Operating System:** Windows or Linux.
- **Region:** Geographical location (e.g., West US, East US).
- **VM Instances:** Number of virtual machine instances.
- **VM Size:** Small, Medium, Large, etc.
- **Pricing Tier:** Determines features and cost:
  - **Shared Compute:** Free, Shared
    - Apps run on shared Azure VMs with other customers' apps.
    - CPU quotas are allocated; cannot scale out.
    
  - **Dedicated Compute:** Basic, Standard, Premium, PremiumV2, PremiumV3
    - Apps run on dedicated VMs.
    - Shared among apps in the same plan.
    
  - **Isolated:** Isolated, IsolatedV2
    - Provides dedicated VMs on isolated Azure Virtual Networks.
    - Maximum scale-out capabilities.

**Note:** Free and Shared tiers are for development and testing, not production.

#### **App Execution and Scaling:**

- **Free and Shared Tiers:** 
  - Apps receive CPU minutes on shared instances.
  - No scale-out capability.

- **Other Tiers (Dedicated and Isolated):**
  - **Execution:** Apps run on all configured VM instances in the plan.
  - **Scaling:** 
    - All apps within the plan scale together.
    - Multiple deployment slots share VM instances.
    - Diagnostics, backups, WebJobs also consume resources from these instances.

#### **Scaling Up or Down:**

- **Flexibility:** You can change the pricing tier at any time, which scales the plan up or down.

#### **App Performance Considerations:**

- **Isolating Apps:** 
  - Move resource-intensive apps to their own App Service plan.
  - Allows independent scaling and resource allocation.

- **Cost Saving:** 
  - Multiple apps in one plan can reduce costs if resource use is complementary.

- **When to Isolate:**
  - App is resource-heavy.
  - Independent scaling is required.
  - App needs resources in a different geographical region.

#### **Implementation Steps for App Service Plans:**

- **Creating an App Service Plan:**
  ```bash
  az appservice plan create --name myAppServicePlan --resource-group <resource-group-name> --sku FREE
  ```

- **Scaling an App Service Plan:**
  ```bash
  # Scale up to Standard tier
  az appservice plan update --resource-group <resource-group-name> --name <app-service-plan-name> --sku S1

  # Scale out (increase instance count)
  az appservice plan update --resource-group <resource-group-name> --name <app-service-plan-name> --number-of-workers 5
  ```

- **Moving an App to a New Plan:**
  - Create a new plan with desired specs.
  - Use the Azure portal or CLI to move the app to this new plan.

#### **Conclusion:**

App Service plans are crucial for defining the compute environment for your Azure web apps. Understanding when and how to scale or isolate your applications within these plans is key to optimizing performance and cost-efficiency. Remember to consider the resource demands of your apps and their growth when planning your Azure App Service strategy.

### **Deployment Options for Azure App Service**

#### **Automated Deployment (Continuous Deployment):**

- **Benefits:** Streamlines the release of new features and bug fixes with minimal impact on users.

- **Supported Sources:**
  - **Azure DevOps Services:**
    - Steps: Push code, build in cloud, run tests, create release, deploy to Azure Web App.
  
  - **GitHub:**
    - Connect repository for automatic deployment on production branch updates.
  
  - **Bitbucket:**
    - Similar setup to GitHub for automated deployments.

#### **Manual Deployment:**

- **Git Deployment:**
  - **Process:** Add Azure App Service as a remote Git repository, push code to deploy.
    ```bash
    # Add Azure as a remote repository (example URL)
    git remote add azure https://<deployment-username>@<app-name>.scm.azurewebsites.net/<app-name>.git

    # Push to Azure
    git push azure master
    ```

- **Azure CLI:**
  - **Command:** `az webapp up` can deploy or create and deploy an app.
    ```bash
    az webapp up --name <app-name> --resource-group <resource-group-name> --sku F1
    ```

- **Zip Deploy:**
  - **Method:** Push a zip file of your app to App Service via HTTP.
    ```bash
    # Example using curl
    curl -X POST -u <username>:<password> --data-binary @<filename>.zip <app-url>/api/zipdeploy
    ```

- **FTP/S Deployment:**
  - Traditional file transfer method for code deployment.

#### **Using Deployment Slots:**

- **Purpose:** Allows staging deployments to reduce risk and downtime.
  - **Create a Slot:**
    ```bash
    az webapp deployment slot create --name <app-name> --resource-group <resource-group-name> --slot staging
    ```
  - **Swap Slots:**
    ```bash
    az webapp deployment slot swap --name <app-name> --resource-group <resource-group-name> --slot staging --target-slot production
    ```

- **Best Practices:**
  - Use slots for staging before production deployment.
  - Test, QA, and staging branches should deploy to different staging slots.

#### **Continuous Deployment for Containers:**

- **Workflow for Custom Containers:**
  1. **Build and Tag the Image:**
     - Tag with git commit ID or timestamp for traceability.
       ```docker
       docker build -t myappregistry.azurecr.io/myapp:v1.0-${GIT_COMMIT} .
       ```

  2. **Push the Image:**
     - Push to Azure Container Registry or similar.
       ```bash
       az acr login --name myappregistry
       docker push myappregistry.azurecr.io/myapp:v1.0-${GIT_COMMIT}
       ```

  3. **Update Deployment Slot:**
     - Update the image tag for the staging slot to trigger a restart and image pull.
       ```bash
       az webapp config container set --resource-group <resource-group-name> --name <app-name> --slot staging --docker-registry-server-url <container-registry-url> --docker-custom-image-name myappregistry.azurecr.io/myapp:v1.0-${GIT_COMMIT}
       ```

#### **Conclusion:**

- **Automation:** Key for reducing manual errors and improving efficiency.
- **Slots:** Essential for zero-downtime deployments and testing.
- **Containers:** Require additional considerations for tagging and updating but offer flexibility and consistency across environments.

### **Exploring Authentication and Authorization in Azure App Service**

#### **Overview:**

- **Purpose:** Azure App Service offers built-in authentication and authorization to secure your applications effortlessly.

#### **Why Use Built-in Authentication:**

- **Time and Effort Savings:**
  - Minimizes or eliminates the need for custom authentication code.
  - Focuses your development efforts on business logic rather than security infrastructure.

- **Flexibility:**
  - While you can opt for custom security implementations, the built-in feature offers immediate usability.

- **Native Integration:**
  - Authentication is integrated into the platform, requiring no specific language or SDK.

#### **Key Features of App Service Authentication:**

- **Federated Identity Providers:**
  - **Support for Multiple Providers:**
    - Microsoft Entra ID (formerly Azure AD)
    - Facebook
    - Google
    - X (formerly Twitter)
  
  This allows users to sign in with their existing accounts, enhancing user experience and simplifying user management.

- **No Code Requirement:**
  - Authentication can be configured through the Azure portal or Azure CLI without altering your application code.

#### **Implementation Steps:**

1. **Enable Authentication in App Service:**

   - Go to the Azure portal, navigate to your App Service, and under **Settings**, click on **Authentication / Authorization**.
   - Toggle **App Service Authentication** to **On**.

   ```bash
   # Enable authentication for an app using Azure CLI
   az webapp auth update --resource-group <resource-group-name> --name <app-name> --enabled true --action AllowAnonymous
   ```

2. **Configure Authentication Providers:**

   - Select the identity providers you want to use. For example:

     ```bash
     # Configure Microsoft Entra ID as an auth provider
     az webapp auth microsoft update --resource-group <resource-group-name> --name <app-name> \
       --client-id <client-id> --client-secret <client-secret> --issuer-url <issuer-url>
     ```

3. **Authorization Settings:**
   - Choose how your app handles unauthenticated requests:
     - **AllowAnonymous:** Allows anonymous access but still provides authentication tokens if available.
     - **Log in with <provider-name>:** Redirects unauthenticated users to a login page for the specified provider.

4. **Additional Configurations:**
   - **Token Store:** Can be enabled to cache tokens for your app, simplifying subsequent authentication checks.

#### **Considerations:**

- **Custom Authentication:** If App Service's authentication doesn't meet your needs, you can still implement custom solutions.
  - This might be necessary for specialized authorization logic, integration with unsupported providers, or if you need more control over the security workflow.

- **Security Best Practices:** 
  - Even with built-in authentication, ensure to follow security best practices like:
    - Use HTTPS to encrypt data in transit.
    - Implement proper authorization logic within your app to complement authentication.

- **User Identity Information:**
  - When a user is authenticated, their identity claims are available through the request headers for your application to use.

#### **Conclusion:**

Azure App Serviceâ€™s built-in authentication and authorization features provide a straightforward way to secure your applications, supporting multiple identity providers out of the box. This feature allows developers to maintain application security without deep dives into security implementation details, freeing up time to enhance the application's core functionalities.

### **Exploring Authentication and Authorization in Azure App Service**

#### **Identity Providers**

Azure App Service supports federated identity where a third-party provider manages user identities and the authentication process. Here are the default providers:

- **Microsoft Identity Platform:**
  - **Endpoint:** `/.auth/login/aad`
  - **Documentation:**[App Service Microsoft identity platform login](link to doc)

- **Facebook:**
  - **Endpoint:** `/.auth/login/facebook`
  - **Documentation:**[App Service Facebook login](link to doc)

- **Google:**
  - **Endpoint:** `/.auth/login/google`
  - **Documentation:**[App Service Google login](link to doc)

- **X (formerly Twitter):**
  - **Endpoint:** `/.auth/login/twitter`
  - **Documentation:**[App Service X login](link to doc)

- **Any OpenID Connect Provider:**
  - **Endpoint:** `/.auth/login/<providerName>`
  - **Documentation:**[App Service OpenID Connect login](link to doc)

- **GitHub:**
  - **Endpoint:** `/.auth/login/github`
  - **Documentation:**[App Service GitHub login](link to doc)

Each provider's endpoint is used for user authentication and token validation.

#### **How Authentication and Authorization Works**

- **Module Execution:** 
  - The authentication module operates in the same sandbox as your application for Windows, but in a separate container for Linux and custom containers.

- **Request Handling:**
  - **Authentication:** Handles user and client authentication with the specified identity provider.
  - **Token Management:** Validates, stores, and refreshes OAuth tokens.
  - **Session Management:** Manages the authenticated session state.
  - **Header Injection:** Injects identity information into HTTP headers.

- **Configuration:**
  - Can be set up via Azure Resource Manager settings or a configuration file, without requiring SDKs or code changes.

- **Platform Independence:**
  - This system is language-agnostic, meaning you don't need to modify your application's code to utilize the authentication features.

**Note for Linux and Containers:**
  - Authentication runs in a separate, isolated container, which means there's no direct in-process integration with language frameworks.

#### **Example Configuration via Azure CLI:**

To enable authentication for an app with Microsoft Entra ID:

```bash
az webapp auth update --resource-group <resource-group-name> --name <app-name> \
  --enabled true --action AllowAnonymous \
  --aad-client-id <client-id> --aad-client-secret <client-secret> \
  --aad-issuer-url <issuer-url>
```

#### **Key Points:**

- **Multiple Providers:** You can configure multiple sign-in options for users.
- **No Code Changes:** Authentication can be enabled without altering your application's codebase.
- **Security Features:** 
  - Token management ensures secure and efficient handling of OAuth tokens.
  - Session management keeps users signed in across requests.

#### **Conclusion:**

Azure App Service's authentication and authorization capabilities simplify securing your applications by offloading the complexities of identity management to trusted providers. This integration allows for a seamless setup where your application remains focused on its core functionality while the platform handles user identity and security.

### **Authentication Flow in Azure App Service**

#### **Overview:**

- **Provider SDK Usage:** The flow varies based on whether the application uses the identity provider's SDK or relies on App Service for authentication.

#### **Authentication Flow Steps:**

- **Without Provider SDK (Server-Directed Flow):**
  1. **Sign User In:**
     - Redirects to `/.auth/login/<provider>`.

  2. **Post-Authentication:**
     - Provider redirects back to `/.auth/login/<provider>/callback`.

  3. **Establish Authenticated Session:**
     - App Service adds an authenticated cookie to the response.

  4. **Serve Authenticated Content:**
     - Client includes the authentication cookie in subsequent requests (handled by the browser).

- **With Provider SDK (Client-Directed Flow):**
  1. **Sign User In:**
     - Client code uses the provider's SDK to authenticate and receive a token.
     - See provider's documentation for specifics.

  2. **Post-Authentication:**
     - Client code sends the token to `/.auth/login/<provider>` for validation.

  3. **Establish Authenticated Session:**
     - App Service returns its authentication token.

  4. **Serve Authenticated Content:**
     - Client presents the token in the `X-ZUMO-AUTH` header (handled by Mobile Apps client SDKs).

**Note:** For browser clients, App Service can automatically redirect unauthenticated users to `/.auth/login/<provider>`.

#### **Authorization Behavior Configuration:**

- **Allow Unauthenticated Requests:**
  - Authentication is deferred to your application code.
  - Authenticated requests include authentication info in headers.
  - Useful for presenting multiple sign-in options or handling anonymous requests.

- **Require Authentication:**
  - Rejects unauthenticated traffic:
    - **Redirect:** Sends the user to `/.auth/login/<provider>`.
    - **HTTP 401 Unauthorized:** For native mobile apps or when configured to return unauthorized.
    - **HTTP 403 Forbidden:** Can be set as the rejection response.

**Caution:** 
  - Requiring authentication for all calls might not be suitable for apps with public pages, like single-page applications.

#### **Configuration via Azure Portal:**

- **Authentication Settings:**
  - Navigate to your App Service in the Azure portal.
  - Go to **Authentication / Authorization** under **Settings**.
  - **Toggle Authentication:** On.
  - **Choose Action:** Select how to handle unauthenticated requests (Allow or Require).

#### **Example Configuration via Azure CLI:**

To configure App Service to require authentication with redirection:

```bash
az webapp auth update --resource-group <resource-group-name> --name <app-name> \
  --enabled true --action LoginWithMicrosoftAccount
```

#### **Conclusion:**

Azure App Service provides a flexible authentication framework that can operate with or without direct integration with provider SDKs. The choice between server-directed and client-directed flows depends on your application's nature and interaction with users. The authorization settings allow you to control access to your application, balancing between security and user experience.

### **Token Store in Azure App Service**

#### **Overview:**

- **Function:** Azure App Service includes a built-in token store for managing tokens associated with authenticated users.

- **Activation:** 
  - Automatically enabled when you configure authentication with any identity provider.

#### **Token Store Benefits:**

- **Token Management:** 
  - Stores tokens issued by the identity providers.
  - Handles token refresh automatically, reducing the need for users to re-authenticate.

- **Session Management:**
  - Helps maintain authenticated sessions across requests without repeated authentication.

### **Logging and Tracing in App Service**

#### **Purpose:**

- **Authentication Insights:** Provides detailed logs for troubleshooting authentication issues.

#### **Implementation:**

- **Enable Application Logging:**
  - Go to your App Service in the Azure portal.
  - Under **Monitoring**, select **App Service logs**.
  - Enable **Application Logging (Filesystem)** or **Application Logging (Blob)**.

- **Viewing Logs:**
  - **Log Stream:** In the Azure portal, you can use the Log stream to view logs in real-time.
  - **Log Files:** Logs are stored in the `LogFiles` directory of your App Service or in the specified Blob storage.

#### **Log Content:**

- **Authentication and Authorization Traces:** 
  - Logs include information about authentication requests, token validation, and any errors encountered.
  - Useful for diagnosing issues like unexpected authentication failures.

#### **Example Configuration via Azure CLI:**

To enable application logging:

```bash
az webapp log config --resource-group <resource-group-name> --name <app-name> \
  --application-logging true --level verbose --web-server-logging filesystem
```

And to view logs:

```bash
az webapp log tail --resource-group <resource-group-name> --name <app-name>
```

#### **Notes:**

- **Security:** Ensure that log files containing sensitive authentication information are secured and not exposed publicly.

- **Best Practices for Logging:**
  - Regularly review logs for security events.
  - Use logs for performance tuning and debugging beyond just authentication issues.
  - Consider integrating with Azure Monitor for advanced log analysis and alerts.

#### **Conclusion:**

The token store simplifies the management of OAuth tokens, enhancing user experience by seamlessly handling session maintenance. Meanwhile, the logging and tracing capabilities ensure that you can troubleshoot authentication problems efficiently, with comprehensive details logged directly in your application's log files.

### **Azure App Service Networking Features**

#### **Overview:**

- **Default Accessibility:** Apps in App Service are internet-accessible by default, with outbound traffic limited to internet endpoints.

- **Deployment Types:**
  - **Multi-tenant:** Includes Free, Shared, Basic, Standard, Premium, PremiumV2, PremiumV3 SKUs.
  - **Single-tenant:** App Service Environment (ASE) for Isolated SKU plans within a virtual network.

#### **Multi-tenant Networking Features:**

- **Network Architecture:**
  - **Front Ends:** Handle incoming HTTP/HTTPS requests.
  - **Workers:** Host customer workloads.
  - **Network Isolation:** Not directly connectable to your network due to multi-tenant environment.

- **Networking Features:**

  **Inbound Traffic Control:**
  - **App-assigned Address:**
    - Provides a dedicated IP for SSL needs or a unique inbound address.
    ```bash
    # Assign a custom domain to an app (which can have a dedicated IP)
    az webapp config hostname add --resource-group <resource-group-name> --name <app-name> --hostname <custom-domain>
    ```

  - **Access Restrictions:**
    - Restricts access to your app based on IP addresses.
    ```bash
    # Add an IP restriction
    az webapp config access-restriction add --resource-group <resource-group-name> --name <app-name> --rule-name "AllowSpecificIP" --action Allow --ip-address <ip-address>
    ```

  - **Service Endpoints:**
    - Allows secure access to Azure services like Azure Storage from your app.

  - **Private Endpoints:**
    - Connects your app privately to Azure services or on-premises networks without internet exposure.

  **Outbound Traffic Control:**
  - **Hybrid Connections:**
    - Enables connectivity to on-premises systems securely.
    ```bash
    # Create a Hybrid Connection endpoint
    az relay hybrid-connection create --resource-group <resource-group-name> --namespace-name <namespace-name> --name <hybrid-connection-name> --type HybridConnection
    ```

  - **Gateway-required Virtual Network Integration:**
    - Allows your app to connect to resources in a virtual network via an Azure Application Gateway or a VPN Gateway.

  - **Virtual Network Integration:**
    - Enables your app to access resources within an Azure VNet.

#### **Inbound Use Cases:**

- **SSL Certificate Binding:**
  - **Feature:** App-assigned address for IP-based SSL.

- **Dedicated Inbound Address:**
  - **Feature:** App-assigned address to provide a unique inbound IP.

- **IP Whitelisting:**
  - **Feature:** Access restrictions to allow access only from specific IP addresses.

#### **Notes:**

- **Feature Compatibility:** Mixing features is possible, but there are limitations due to the nature of the multi-tenant environment.
- **Security:** By using these features, you can significantly enhance the security of your applications by controlling who can access them and how they communicate outward.

#### **Conclusion:**

Azure App Service networking features offer a robust set of tools for controlling both inbound and outbound traffic. These features allow developers to tailor network behavior to specific application requirements, ensuring both security and connectivity needs are met without compromising on performance or user experience.

### **Default Networking Behavior in Azure App Service**

#### **Overview:**

- **Scale Units:** Azure App Service runs on scale units that serve multiple customers.

- **VM Types:**
  - **Free, Shared, Basic, Standard, Premium:** Share similar worker VM types.
  - **PremiumV2:** Uses a different VM type.
  - **PremiumV3:** Uses yet another VM type.

#### **Outbound Addresses:**

- **Worker VMs and Outbound IPs:**
  - Apps share outbound IP addresses based on the VM family they run on.
  - Changing to a different VM family (like moving to PremiumV2 or PremiumV3) changes the set of outbound IPs.

- **Address Sharing:**
  - The outbound addresses are used by all apps on the same worker VM family within an App Service deployment.

#### **Finding Outbound IP Information:**

- **Azure Portal:**
  - Navigate to your app in the Azure portal.
  - Go to **Properties** in the left-hand navigation to view current outbound IP addresses.

- **Azure CLI Commands:**

  **Current Outbound IP Addresses:**
  ```bash
  az webapp show \
      --resource-group <group_name> \
      --name <app-name> \
      --query outboundIpAddresses \
      --output tsv
  ```

  **Possible Outbound IP Addresses (for all tiers):**
  ```bash
  az webapp show \
      --resource-group <group_name> \
      --name <app-name> \
      --query possibleOutboundIpAddresses \
      --output tsv
  ```

#### **Notes:**

- **Scaling:** When scaling out, all apps in the same App Service plan are replicated across new instances, but they will share the same set of outbound IPs unless you change VM families.

- **Predictability:** Knowing the possible outbound IPs is useful for firewall rules or when integrating with services that require IP whitelisting.

- **Multi-Tenant Implications:** In multi-tenant environments (Free and Shared), your app might share an outbound IP with other customers' apps, which might not be ideal for some scenarios.

#### **Conclusion:**

Understanding and managing outbound IP addresses in Azure App Service is crucial for applications that need to communicate externally or integrate with services that whitelist IPs. The ability to scale while maintaining or managing these addresses allows for flexible deployment strategies tailored to security and connectivity needs.

### **Exercise: Create a Static HTML Web App Using Azure Cloud Shell**

#### **Prerequisites:**

- **Account Verification:** Use the free Azure sandbox which allows resource creation in specific regions.

#### **Step-by-Step Guide:**

1. **Switch to Classic Cloud Shell:**
   - After loading the Cloud Shell, go to **Settings** and select **Go to Classic version**.

2. **Download the Sample App:**

   - Create and navigate to a new directory:
     ```bash
     mkdir htmlapp
     cd htmlapp
     ```

   - Clone the sample repository:
     ```bash
     git clone https://github.com/Azure-Samples/html-docs-hello-world.git
     ```

   - Set up variables for resource group and app name:
     ```bash
     resourceGroup=$(az group list --query "[].{id:name}" -o tsv)
     appName=az204app$RANDOM
     ```

3. **Create the Web App:**

   - Change to the sample code directory:
     ```bash
     cd html-docs-hello-world
     ```

   - Deploy the app using the `az webapp up` command:
     ```bash
     az webapp up -g $resourceGroup -n $appName --html
     ```

   - This command will:
     - Create a resource group if needed.
     - Create an App Service plan.
     - Create a web app.
     - Deploy files from the current directory.

   - Note the `app_url` from the output to verify your app in a browser.

4. **Verify Deployment:**

   - Open the app URL in a new browser tab to ensure the site is up and running.

5. **Update and Redeploy the App:**

   - Edit the HTML file:
     ```bash
     code index.html
     ```
     - Modify the `<h1>` tag content.
     - Use `Ctrl+S` to save, then `Ctrl+Q` to exit.

   - Redeploy the updated app:
     ```bash
     az webapp up -g $resourceGroup -n $appName --html
     ```
     - You can recall this command using the up-arrow key.

   - Refresh the browser tab to see your changes.

#### **Notes:**

- **Region:** Ensure to select one of the available regions for your sandbox deployment.

- **Command Utility:** The `az webapp up` command simplifies the deployment process by handling several steps automatically.

- **Environment:** This exercise assumes you're working in a Cloud Shell environment, where you don't need to install the Azure CLI locally.

#### **Conclusion:**

This exercise demonstrates how to quickly set up, deploy, and update a static HTML site using Azure App Service and Azure CLI commands in the Cloud Shell. It's an excellent way to get started with Azure web services, showcasing the ease of deployment and the power of Azure's command-line tools for managing applications.

### Azure Web App Configuration

**Objective**: Learn to configure various settings for Azure web apps.

#### Application Settings

- **Create and Manage Application Settings**: Application settings in Azure can be used to store configuration information:
  ```plaintext
  az webapp config appsettings set --resource-group <resource-group-name> --name <app-name> --settings <key>=<value>
  ```

#### SSL/TLS Certificates

- **Install SSL/TLS Certificates**: Secure web traffic by adding SSL/TLS certificates.
  ```plaintext
  az webapp config ssl import --resource-group <resource-group-name> --name <app-name> --cert-file <path-to-cert-file> --key-file <path-to-key-file> --password <certificate-password>
  ```

#### Diagnostic Logging

- **Enable Diagnostic Logging**: Helps in troubleshooting and monitoring:
  ```plaintext
  az webapp log config --resource-group <resource-group-name> --name <app-name> --application-logging filesystem --detailed-error-messages true --failed-request-tracing true
  ```

#### Virtual App to Directory Mappings

- **Create Virtual App to Directory Mappings**: Map a virtual path to a physical directory:
  ```plaintext
  az webapp config set --resource-group <resource-group-name> --name <app-name> --virtual-applications '[{"virtualPath": "/myapp", "physicalPath": "site\\wwwroot\\myapp"}]'
  ```

#### Managing App Features

- **App Features**: Various features can be enabled or disabled via Azure CLI or portal. For example, to enable Always On:
  ```plaintext
  az webapp config set --resource-group <resource-group-name> --name <app-name> --always-on true
  ```

### Key Points:

- **Configuration**: Application settings are crucial for runtime configuration without changing code.
- **Security**: SSL/TLS certificates are vital for secure communications.
- **Monitoring**: Logging is key for debugging and performance monitoring.
- **Flexibility**: Virtual directory mappings offer flexibility in how applications are structured and served. 

This script provides a quick reference for managing Azure web app settings, focusing on security, performance, and configuration management. Remember, these are just the basic commands; always check Azure documentation for the latest CLI options and best practices.

### Azure App Service Introduction

#### Key Concept: App Settings

- **Purpose**: App settings in Azure App Service are essentially environment variables that provide a way to configure your application without changing its code.

#### Learning Objectives:

1. **Create Application Settings**:
   - Application settings can be slot-specific or shared across deployment slots:
     ```plaintext
     az webapp config appsettings set --resource-group <resource-group-name> --name <app-name> --slot <slot-name> --settings <key>=<value>
     ```
   - For shared settings across all slots:
     ```plaintext
     az webapp config appsettings set --resource-group <resource-group-name> --name <app-name> --settings <key>=<value>
     ```

2. **SSL/TLS Certificates**:
   - Understanding how to secure your app with SSL/TLS:
     - **Import a certificate**: 
       ```plaintext
       az webapp config ssl import --resource-group <resource-group-name> --name <app-name> --cert-file <path-to-cert-file> --key-file <path-to-key-file> --password <certificate-password>
       ```
     - **Bind certificate to hostname**:
       ```plaintext
       az webapp config ssl bind --resource-group <resource-group-name> --name <app-name> --certificate-thumbprint <thumbprint> --ssl-type SNI
       ```

3. **Enable Diagnostic Logging**:
   - Log configuration for better debugging and monitoring:
     ```plaintext
     az webapp log config --resource-group <resource-group-name> --name <app-name> --application-logging filesystem --detailed-error-messages true --failed-request-tracing true
     ```

4. **Virtual App to Directory Mappings**:
   - Useful for structuring applications with different virtual paths mapping to physical directories:
     ```plaintext
     az webapp config set --resource-group <resource-group-name> --name <app-name> --virtual-applications '[{"virtualPath": "/myapp", "physicalPath": "site\\wwwroot\\myapp"}]'
     ```

**Note**: Always check the latest Azure CLI documentation for any updates or changes to command syntax.

These notes summarize the introduction to Azure App Service settings, focusing on application configuration, security, logging, and application structure management. Remember, each of these operations can be performed through the Azure Portal as well, but using the CLI can streamline your workflow, especially in automated environments or scripts.

#### Key Concepts:

- **Application Settings**: These are environment variables provided to your application code in Azure App Service. For Linux apps and custom containers, these are passed using the `--env` flag.

**Accessing Application Settings:**
- Navigate to your app's management page:
  - Go to **Environment variables** > **Application settings**.

**ASP.NET and ASP.NET Core Usage:**
- App settings in App Service override those in `Web.config` or `appsettings.json`.
- Local settings can be kept in `Web.config` or `appsettings.json`, while production secrets should reside in App Service for security.

**Security:**
- All app settings are encrypted at rest.

#### Adding and Editing Settings:

- **Single Setting Addition**: 
  - Select **+ Add** to add a new setting.
  - If using deployment slots, decide if the setting should be slot-specific or swappable.

- **Bulk Editing/Adding Settings**:
  - Use **Advanced edit** for bulk operations. Here's an example JSON format for app settings:
    ```json
    [
      {
        "name": "<key-1>",
        "value": "<value-1>",
        "slotSetting": false
      },
      {
        "name": "<key-2>",
        "value": "<value-2>",
        "slotSetting": false
      }
    ]
    ```

#### Configure Connection Strings:

- For ASP.NET/ASP.NET Core, connection strings in App Service override those in `Web.config`.
- For other languages, app settings are preferred unless you're using specific Azure database types for backups.

**Bulk Editing Connection Strings:**
- JSON format for connection strings:
  ```json
  [
    {
      "name": "name-1",
      "value": "conn-string-1",
      "type": "SQLServer",
      "slotSetting": false
    },
    {
      "name": "name-2",
      "value": "conn-string-2",
      "type": "PostgreSQL",
      "slotSetting": false
    }
  ]
  ```

**Note for .NET Apps with PostgreSQL:**
- Set the connection string type to **Custom** as a workaround for an issue in .NET.

#### Environment Variables for Custom Containers:

- To set environment variables for custom containers:
  - In **Bash** (Azure CLI):
    ```bash
    az webapp config appsettings set --resource-group <group-name> --name <app-name> --settings key1=value1 key2=value2
    ```
  - In **PowerShell** (Azure PowerShell):
    ```powershell
    Set-AzWebApp -ResourceGroupName <group-name> -Name <app-name> -AppSettings @{"DB_HOST"="myownserver.mysql.database.azure.com"}
    ```

- **Verification**:
  - Use the URL `https://<app-name>.scm.azurewebsites.net/Env` to verify the environment variables in your running container.

Remember, when configuring your app, always apply your changes after editing to ensure they take effect.

#### General Settings Overview:

- Navigate to **Configuration > General settings** to manage these settings.

#### List of Available Settings:

**1. Stack Settings:**
- Define the software stack for your app:
  - Language and SDK versions.
  - For Linux and custom container apps:
    - Optional start-up command or file.

**2. Platform Settings:**

- **Platform Bitness**: Choose between 32-bit or 64-bit for Windows apps.
- **FTP State**: 
  - Options include allowing only FTPS or disabling FTP altogether.
- **HTTP Version**:
  - Set to `2.0` for HTTP/2 protocol support.
  ```plaintext
  # Note: Most browsers support HTTP/2 only over TLS. Ensure your custom DNS is secured for HTTP/2 use.
  ```
  
- **Web Sockets**: Enable for real-time features like ASP.NET SignalR or socket.io.
- **Always On**: 
  - Keeps the app loaded without traffic, preventing cold starts:
  ```plaintext
  # Set to ON for maintaining continuous WebJobs or CRON triggered jobs.
  ```
- **ARR Affinity**: 
  - Ensures session stickiness in multi-instance scenarios:
  ```plaintext
  # Set to OFF for stateless applications.
  ```
- **HTTPS Only**: 
  - Redirect all HTTP traffic to HTTPS.
- **Minimum TLS Version**: 
  - Choose the minimum TLS version your app will accept.
- **Debugging**: 
  - Enable remote debugging for specified app types. Automatically turns off after 48 hours.
- **Incoming Client Certificates**: 
  - For mutual TLS authentication, forcing clients to provide certificates for access.

**Important Notes:**
- **Scaling**: Some settings might require scaling to higher pricing tiers.
- **HTTP/2**: Remember to secure your custom DNS name for HTTP/2 usage due to TLS requirements in modern browsers.

These settings are crucial for optimizing your application's performance, security, and compatibility with various technologies and protocols. Always consider your application's specific needs when configuring these options.

#### Path Mappings Overview:

- Navigate to **Configuration > Path mappings** to configure handler mappings and virtual applications/directories.

#### Windows Apps (Uncontainerized)

**Handler Mappings:**
- Custom script processors can be added for specific file extensions:
  - **Extension**: File extension to handle (e.g., `*.php`, `handler.fcgi`).
  - **Script processor**: Path to the script processor (e.g., `D:\home\site\wwwroot` for app root).
    ```plaintext
    # Example configuration for a PHP handler:
    # Extension: *.php
    # Script processor: D:\home\site\wwwroot\php-cgi.exe
    # Arguments: (optional)
    ```
  - **Arguments**: Optional command-line arguments.

**Virtual Applications and Directories:**
- Default path `/` is mapped to `D:\home\site\wwwroot`.
- To configure:
  - Specify virtual directory and physical path relative to `D:\home`.
  - Uncheck **Directory** to mark a virtual directory as a web application.

#### Linux and Containerized Apps

**Custom Storage Mounts:**
- For Linux apps and custom containers (both Windows and Linux):
  - Select **New Azure Storage Mount** to add custom storage:

```plaintext
# Basic Configuration
Name: [Display name of the mount]
Storage accounts: [Select your storage account]
Storage type: [Azure Blobs or Azure Files; Windows containers support only Azure Files]
Storage container: [Select the container in basic setup]

# Advanced Configuration
Share name: [File share name for advanced setup]
Access key: [Access key for advanced setup]
Mount path: [Absolute path in container for mount point]
Deployment slot setting: [Check if this should apply to deployment slots]
```

**Notes:**
- **Azure Blobs** can only be mounted as read-only.
- **Deployment Slot Setting** ensures that storage mounts are consistent across deployment slots when checked.

These configurations allow you to customize how your application handles different file types and how it interacts with external storage, enhancing both functionality and performance based on your operational needs.

### Enable Diagnostic Logging

#### Diagnostic Logging Overview:

- Azure provides various types of logs to help debug and monitor your App Service applications. Here's a breakdown:

| **Type**                | **Platform** | **Location**                               | **Description**                                                                                                                                                                                                                                                                                                                                                                                             |
|-------------------------|--------------|--------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Application logging     | Windows, Linux | App Service file system and/or Azure Storage blobs | Logs messages from your application code. Categories include: **Critical, Error, Warning, Info, Debug, Trace**.                                                                                                                                                                                                                                                                                             |
| Web server logging      | Windows       | App Service file system or Azure Storage blobs    | Records raw HTTP request data in W3C extended log file format. Includes data like HTTP method, resource URI, client IP, client port, user agent, response code, etc.                                                                                                                                                                                                                                    |
| Detailed error messages | Windows       | App Service file system                      | Saves copies of error pages for HTTP errors >= 400. These are not sent to clients for security but are saved for internal review.                                                                                                                                                                                                                                                                    |
| Failed request tracing  | Windows       | App Service file system                      | Provides detailed traces of failed requests, including which IIS components were involved and their processing time. Each failed request generates a folder with an XML log and an XSL stylesheet for viewing.                                                                                                                               |
| Deployment logging      | Windows, Linux | App Service file system                      | Automatically logs deployment activities to help troubleshoot deployment failures. There are no specific settings to configure for this type of logging.                                                                                                                                                                                                 |

**Notes:**
- **Application Logging**: 
  ```plaintext
  # You can configure this to log to the file system or Azure Blob storage.
  # Example configurations might involve setting up log levels and destinations:
  # az webapp log config --application-logging true --level information --web-server-logging filesystem
  ```

- **Web Server Logging**: 
  ```plaintext
  # Can be stored in the file system or Azure Blob storage.
  # az webapp log config --web-server-logging filesystem
  ```

- **Detailed Error Messages** and **Failed Request Tracing** are specific to Windows and offer deep insights into application errors and performance issues.

- **Deployment Logging**: 
  ```plaintext
  # This is automatic upon deployment, no configuration needed.
  ```

### Enable Application Logging

#### For Windows:

- To enable application logging for Windows apps:
  - Navigate to your app in the Azure portal.
  - Select **App Service logs**.

**Configuration Options:**
- **Application Logging (Filesystem)**:
  - Set to **On** for temporary debugging. Automatically turns off after 12 hours.
  - This is useful for quick, short-term troubleshooting.

- **Application Logging (Blob)**:
  - Set to **On** for long-term logging.
  - Requires a blob storage container. Here's how you might set it up:
    ```plaintext
    # Example Blob storage configuration
    # az webapp log config --application-logging blob --level information --name <app-name> --resource-group <resource-group-name>
    # --blob-storage-account <storage-account-name> --blob-container <container-name>
    ```

**Log Levels:**
- Set the logging level for detail control:
  ```plaintext
  # Log Levels:
  # - Disabled: No logging
  # - Error: Errors and Critical
  # - Warning: Warnings, Errors, and Critical
  # - Information: Info, Warning, Error, Critical
  # - Verbose: All categories (Trace, Debug, Info, Warning, Error, Critical)
  ```

- **After configuration, remember to select **Save** to apply changes.**

**Note:**
- If you regenerate storage account keys, you must:
  - Turn logging off and then on again to update the configuration with the new keys.

#### For Linux/Container:

- In **App Service logs**:
  - Set **Application logging** to **File System**.

**Quota and Retention:**
- **Quota (MB)**: Define the disk space allowed for logs.
  ```plaintext
  # Example configuration for quota
  # az webapp log config --application-logging filesystem --level information --name <app-name> --resource-group <resource-group-name> --quota 100
  ```

- **Retention Period (Days)**: Specify how long logs should be kept.
  ```plaintext
  # Example for retention period
  # az webapp log config --retention-in-days 7
  ```

- **When finished, select **Save** to apply the settings.**

These steps ensure you have the appropriate logging enabled for your Windows or Linux/Container apps in Azure, providing you with the necessary logs for debugging or monitoring purposes. Remember, for Linux apps, logs are only saved to the file system, not to Azure Blob Storage.

### Enable Web Server Logging

- To configure web server logging:
  - Select **Storage** for logs to be stored in blob storage, or **File System** for on-site storage on the App Service.

**Retention Period:**
- Set the **Retention Period (Days)** for how long logs should be kept.
  ```plaintext
  # Example for setting retention period
  # az webapp log config --web-server-logging filesystem --retention-in-days 30
  ```

- **When finished, select **Save** to apply the settings.**

### Add Log Messages in Code

**For ASP.NET:**
```csharp
System.Diagnostics.Trace.TraceError("If you're seeing this, something bad happened");
```

**For ASP.NET Core:**
- Uses `Microsoft.Extensions.Logging.AzureAppServices` by default.

**For Python:**
- Use the `OpenCensus` package to send logs.

### Stream Logs

- **Azure Portal**: 
  - Navigate to your app and select **Log stream**.

- **Azure CLI**: Use for live streaming in Cloud Shell:
  ```bash
  az webapp log tail --name appname --resource-group myResourceGroup
  ```

- **Local Console**:
  - Install Azure CLI, sign in, and follow the Azure CLI instructions.

### Access Log Files

**If using Azure Storage for Logs:**
- You'll need a client tool that works with Azure Storage to access the logs.

**For App Service File System Logs:**

- **Download Logs for Linux/Container Apps:**
  ```plaintext
  # URL for downloading logs
  # https://<app-name>.scm.azurewebsites.net/api/logs/docker/zip
  ```

- **Download Logs for Windows Apps:**
  ```plaintext
  # URL for downloading logs
  # https://<app-name>.scm.azurewebsites.net/api/dump
  ```

**Notes:**
- For Linux/containers, the ZIP contains logs from both the docker host and container. For scaled-out apps, there's one set per instance.
- Logs are located in the `/home/LogFiles` directory on the App Service.

This setup allows you to configure where and how long logs are kept, log from within your application, stream logs in real-time, and retrieve them for analysis. Remember, some logs might not be in chronological order due to buffering.

### Configure Security Certificates

#### Overview:

- Azure App Service provides various options to manage certificates for securing data transmission:

| **Option**                               | **Description**                                                                                         |
|-----------------------------------------|---------------------------------------------------------------------------------------------------------|
| Create a free App Service managed certificate | A no-cost private certificate for securing custom domains within App Service.                           |
| Purchase an App Service certificate      | A managed private certificate by Azure with features like automated management and flexible renewals.   |
| Import a certificate from Key Vault     | Suitable for integrating with Azure Key Vault for centralized certificate management.                   |
| Upload a private certificate            | For pre-existing certificates from third-party providers, you can upload directly to App Service.        |
| Upload a public certificate             | For public certificates needed in application code, not for domain security.                            |

#### Private Certificate Requirements:

- For certificates to be used in App Service, they must:

  - Be exported as a **password-protected PFX file** using triple DES encryption.
  - Have a **private key** of at least 2048 bits in length.
  - Include **all intermediate certificates** and the **root certificate** in the chain.

- For securing a custom domain with TLS binding, additional requirements are:

  - Must have an **Extended Key Usage** for server authentication (OID = 1.3.6.1.5.5.7.3.1).
  - Be signed by a **trusted certificate authority**.

**Notes:**
- Certificates uploaded to an app are stored within the deployment unit linked to the app service plan's resource group and region, making them available for other apps sharing the same environment.

This configuration ensures your application's data in transit is secure, using certificates either provided by Azure or brought in from external sources. Remember, when dealing with custom domains, the certificate must meet specific criteria for TLS/SSL bindings.

### Creating a Free Managed Certificate

**App Service Plan Requirements:**
- Your App Service plan must be at least in the **Basic** tier (Standard, Premium, or Isolated also work).

**Steps to Create a Free Managed Certificate:**

1. **Prerequisites**:
   - **Custom DNS Configuration**: Ensure your custom domain is correctly set up with Azure App Service.
   - **CAA Record**: For some domains, you'll need to add a CAA record to allow DigiCert to issue certificates:
     ```plaintext
     0 issue digicert.com
     ```

2. **Certificate Management**:
   - Azure App Service will handle:
     - Certificate issuance by DigiCert.
     - Automatic renewal every six months, 45 days before expiration.

3. **Limitations**:
   - **No Wildcard Certificates**: You cannot use this for wildcard domains like `*.example.com`.
   - **Not for Client Certificates**: Cannot be used with client certificate authentication by thumbprint.
   - **No Private DNS**: Does not work with private DNS zones.
   - **Non-Exportable**: These certificates are managed by Azure and cannot be exported.
   - **ASE Incompatible**: Not supported in App Service Environment.
   - **Character Restrictions**: Only supports alphanumeric characters, dashes (-), and periods (.), with a maximum length of 64 characters for the domain name.

**Key Considerations:**
- **Avoid Certificate Pinning**: Since Azure manages these certificates, the root issuer or other aspects might change, so don't pin to specific certificate details.

This solution provides an effortless way to secure your custom domain in Azure App Service, but be mindful of its limitations, especially if you require more advanced certificate management features.

### Importing an App Service Certificate

**Azure Management for Purchased App Service Certificates:**

- **Purchase**: Azure handles the procurement from the certificate provider.
- **Verification**: Automatically verifies the domain for the certificate.
- **Storage**: Stores the certificate in **Azure Key Vault**.
- **Renewal**: Manages the renewal process.
- **Synchronization**: Automatically updates or synchronizes the certificate across your App Service apps.

**Actions with an Existing App Service Certificate:**

- **Import**: You can import your App Service Certificate into Azure App Service:
  ```plaintext
  # Example command to import a certificate:
  # az webapp config ssl import --resource-group <resource-group-name> --name <app-name> --certificate-name <certificate-name> --key-vault <key-vault-name> --key-vault-certificate-name <vault-certificate-name>
  ```

- **Management**:
  - **Renew**: Extend the validity of your certificate.
  - **Rekey**: Generate a new key pair for the certificate, useful if you suspect key compromise.
  - **Export**: Export the certificate for use elsewhere if needed, although direct export from Azure might not be straightforward, you can download it from Key Vault.

**Important Note:**
- **Azure National Clouds**: App Service Certificates are **not supported** in these environments.

This functionality provides a straightforward method for managing SSL/TLS certificates within Azure, simplifying the process of securing your web applications with minimal manual intervention after the initial setup.

# Azure App Service - Scaling Applications

## Overview
- **Module Duration**: 22 minutes remaining
- **Progress**: 0 of 7 units completed

## Learning Objectives
- **Understand Autoscale**: 
  Learn how autoscale operates within the Azure App Service environment.
  
- **Identifying Autoscale Factors**:
  - **CPU Usage**: When your app exceeds a certain CPU threshold.
  - **Memory Usage**: Similar to CPU, but for memory.
  - **Queue Length**: Useful for applications dealing with message queues.
  - **Request Rate**: Number of HTTP requests over a period.

- **Enabling Autoscale**:
  - **Manual Scale**: Fixed number of instances.
  ```bash
  az webapp update --name MyWebApp --resource-group MyResourceGroup --slots 3
  ```
  
  - **Auto Scale**: Dynamically adjusts based on defined rules.
  ```bash
  az monitor autoscale create --resource MyWebApp --resource-group MyResourceGroup --name MyAutoscale --min-count 1 --max-count 10 --count 1 --recurrence '{ "timeZone": "Pacific Standard Time", "schedule": { "timeZone": "Pacific Standard Time", "days": [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday" ], "hours": 9, "minutes": 0 } }'
  ```

- **Creating Sound Autoscale Conditions**:
  - **Thresholds**: Set appropriate thresholds for scaling actions.
  - **Cool Down Periods**: Prevent rapid scaling up and down by setting a cool down time.
  - **Prevent Over-Scaling**: Ensure you don't scale beyond what your system can handle or what's necessary.

## Key Takeaways
- Autoscale helps in managing costs by scaling down during off-peak times and scaling up when demand increases.
- Proper configuration is crucial to avoid unnecessary scaling which can lead to higher costs or poor performance during unexpected traffic spikes.

## Actions
- **Review Current Settings**: Check existing autoscale settings for your apps.
- **Configure Autoscale**: Use the Azure portal or CLI to set up or adjust autoscale rules.
- **Monitor and Adjust**: Regularly check performance metrics and adjust rules as needed for optimal operation.

This script provides an overview, key learning points, and examples of how to scale applications in Azure App Service using both manual and automatic scaling methods. Remember, the key to effective autoscaling is understanding your application's performance needs and setting conditions that align with those needs while keeping costs in check.

# Introduction to Autoscaling in Azure

## Key Points:
- **Autoscaling** dynamically adjusts the resources of your application based on usage, thereby optimizing performance and cost.

## Learning Objectives:
1. **Identify Scenarios for Autoscaling:**
   - E-commerce sites during sales events
   - Social media platforms during viral content
   - Any application expecting variable load patterns

2. **Create Autoscaling Rules for a Web App:**
   - Rules are based on metrics like CPU usage, memory consumption, or request rates.

   **Example of Setting Autoscaling for a Web App:**
   ```bash
   az monitor autoscale create --resource MyWebApp --resource-group MyResourceGroup --name MyAutoscaleRules --min-count 1 --max-count 10 --count 1 --recurrence '{ "timeZone": "Pacific Standard Time", "schedule": { "timeZone": "Pacific Standard Time", "days": [ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday" ], "hours": 9, "minutes": 0 } }'
   ```

3. **Monitor the Effects of Autoscaling:**
   - Use Azure Monitor to track how autoscaling impacts your application.
   - Look for metrics like instance count, response times, and resource utilization.

   **Example of Monitoring Autoscale Effects:**
   ```bash
   az monitor metrics list --resource MyWebApp --metric-names CpuPercentage --interval PT1M --aggregation average
   ```

## Glossary:
- **Autoscale Condition**: Criteria used to determine when to scale up or down.
- **Cool Down Period**: Time to wait before the next scaling action to prevent rapid scaling.

## Why Autoscaling?
- **Scalability**: Handles traffic spikes without manual intervention.
- **Cost Efficiency**: Scales down during low usage to save on costs.
- **Performance**: Maintains performance by adding resources when needed.

## Best Practices:
- **Set Realistic Thresholds**: Too low might lead to unnecessary scaling, too high might degrade performance.
- **Use Sensible Cool Down Periods**: Prevents rapid, costly fluctuations.
- **Test Autoscale Settings**: Simulate load to ensure autoscaling works as expected.

These notes cover the essentials of autoscaling in Azure, including why it's useful, how to implement it, and what to monitor after implementation. Remember, the actual metrics and thresholds you'll use will depend on your specific application's needs and behavior.

# Azure Autoscaling & Automatic Scaling

## Autoscaling Overview
- **Definition**: Autoscaling is a mechanism to adjust resources based on demand.
- **Functionality**: Scales **in** or **out** (not up or down).
  - **Triggers**: 
    - **Schedule-based**
    - **Metric-based** (e.g., CPU, memory, requests)

## Azure App Service Scaling Options

### 1. **Autoscaling with Azure Autoscale**
   - **Mechanism**: Uses rules defined by the user to scale.
   - **Purpose**: Adds or removes resources to meet demands.

### 2. **Azure App Service Automatic Scaling**
   - **Mechanism**: Automatically scales based on selected parameters without user-defined rules.

## Azure App Service Autoscaling Features
- **Monitors**: Resource metrics like CPU, memory, etc.
- **Action**: 
  - Adds or removes **web servers**
  - Balances load across servers
- **Does Not**: Change individual server's CPU, memory, or storage capacity.

## Key Points
- **Scaling Direction**: 
  - **Out**: Adds more instances
  - **In**: Reduces instances
- **Response**: Proactive to ensure resources are available before overload occurs.

Remember, with Azure App Service, you're not just throwing more hardware at the problem; you're smartly managing your cloud resources to match your app's workload!

# Azure Autoscaling Rules

## Rule Definition
- **Purpose**: Define thresholds for metrics to trigger scaling events.
- **Components**:
  - **Trigger**: Metric crossing a specified threshold.
  - **Action**: Scale **in** or **out** accordingly.

### Considerations for Rules:
- **DoS Protection**: Avoid scaling in response to malicious traffic spikes. Instead:
  - Implement request filtering and detection mechanisms.

## When to Use Autoscaling

### Benefits:
- **Elasticity**: Scales with workload changes, ideal for:
  - Holiday traffic spikes in e-commerce.
- **Availability & Fault Tolerance**:
  - Prevents request denial due to instance overload or crash.

### Limitations:
- **Resource-Intensive Requests**: 
  - If each request requires significant processing:
    ```markdown
    - Autoscaling might not suffice; consider manual scaling up instead.
    ```
- **Long-Term Growth**: 
  - Autoscaling has monitoring overhead. Manual scaling might be more cost-effective for predictable growth.

### Instance Count:
- **Few Instances**: 
  - Limited initial capacity can lead to service downtime despite autoscaling.

## Best Practices:
- **Careful Rule Settings**: Ensure rules do not misinterpret malicious traffic as legitimate load.
- **Evaluate Workload**: Determine if autoscaling meets your application's processing demands or if manual intervention is needed.

- **Monitor and Adjust**: Regularly review autoscaling performance against your app's real-world demands to optimize cost and performance.

Remember, autoscaling is not a one-size-fits-all solution. It's about having the right number of servers at the right time, not necessarily about having the most powerful servers all the time.

# Azure App Service Automatic Scaling

## Overview:
- **Purpose**: Automatically manages scale-out decisions for web apps and App Service Plans.
- **Difference from Azure Autoscale**: 
  - **Autoscale**: User-defined rules based on schedules/resources.
  - **Automatic Scaling**: Platform makes decisions based on app performance needs.

## Features:
- **Prewarming**: 
  - The system prewarms instances to buffer performance during scale-out events.
- **Billing**: 
  - **Per-second**: You're charged for each instance, including prewarmed ones.

## When to Use Automatic Scaling:

1. **Simplified Configuration**:
   - If you wish to avoid the complexity of setting up and managing autoscale rules.

2. **Independent Scaling**:
   - When you need different web apps within the same App Service Plan to scale independently.

3. **Backend Integration**:
   - For web apps linked with slower-scaling backends like databases or legacy systems:
     - **Setting Limits**: You can define a maximum number of instances to prevent overwhelming backend resources.

## Key Points:
- Automatic scaling aims to:
  - **Improve Performance**: By avoiding cold starts and ensuring smooth performance transitions.
  - **Balance Load**: Automatically adjusts to the workload without manual rule setting.

Remember, with automatic scaling, you're paying for flexibility and performance. Every second counts, quite literally!

# Azure Autoscaling Factors

## Purpose of Autoscaling:
- **Ensure Resources**: Available for high demand periods.
- **Cost Management**: Scale back during low demand.

## Configuration Options:
- **Resource-Based Scaling**:
  - Scales based on metrics like CPU usage, memory, etc.
- **Schedule-Based Scaling**:
  - Scales according to predefined time schedules.

## Understanding Autoscaling in App Service Plans:

### **App Service Plan and Autoscaling**:
- Autoscaling is tied to the **App Service Plan** (ASP) configuration of the web app.
  - **Scaling Out**: Azure provisions new hardware instances as specified by the ASP.

### **Instance Limits**:
- **Prevent Over-Scaling**: Each ASP has a limit on how many instances can be created:
  - **Pricing Tier**: Determines the maximum number of instances for autoscaling.

### **Important Note**:
- **Tier Limitations**: Not all pricing tiers of the App Service Plan support autoscaling. Check your plan's capabilities before relying on autoscaling.

## Key Takeaways:
- **Metrics**: Use resource metrics smartly to trigger scaling events.
- **Scheduling**: Anticipate regular demand changes with schedule-based autoscaling.
- **Plan Limits**: Be aware of your App Service Plan's instance limit to manage expectations and costs.

# Autoscale Conditions in Azure

## Autoscaling Options:
- **Metric-Based Scaling**: 
  - **Example Metrics**: 
    - Disk queue length
    - Number of HTTP requests pending
- **Schedule-Based Scaling**: 
  - **Example**: Scale out at specific times/days, with an end date for scaling back in.

## Combining Scaling Approaches:
- Can combine both metric and schedule-based scaling for more nuanced control.
  - **Example**: Scale out based on HTTP requests but only during business hours.

## Multiple Conditions:
- **Multiple Rules**: Different conditions can be set for various scenarios.
- **Default Condition**: Always active if other conditions don't apply; no schedule needed.

## Metrics for Autoscale Rules:
- **CPU Percentage**: Indicates CPU utilization across instances.
  - High value = potential for processing delays.
- **Memory Percentage**: Shows memory usage.
  - High value = risk of memory depletion.
- **Disk Queue Length**: Measures outstanding I/O requests.
  - High value = potential disk contention.
- **Http Queue Length**: Shows pending HTTP requests.
  - Large number = risk of HTTP 408 errors.
- **Data In/Out**: Monitors network traffic in and out.

### Cross-Service Metrics:
- Can also scale based on metrics from other Azure services, e.g., Azure Service Bus Queue length.

## Key Points:
- **Autoscale Rules**: Define when to scale based on metrics.
- **Flexibility**: Combine rules to match your app's unique traffic patterns and resource needs.
- **Monitoring**: Keep an eye on multiple dimensions to ensure your app scales appropriately.

Remember, setting up autoscaling is like setting up a smart thermostat for your app's environment - it keeps everything at just the right level without you having to do much more than define the comfort zones.

# How Autoscale Rules Analyze Metrics

## Metric Analysis Steps:

### 1. **Time Grain Aggregation**:
- **Definition**: Aggregates metric values for all instances over a short time period.
  - **Typical Time Grain**: 1 minute.
  - **Aggregation Options**: 
    - Average
    - Minimum
    - Maximum
    - Sum
    - Last
    - Count

### 2. **Duration Aggregation**:
- **Purpose**: To assess if changes are significant enough for scaling.
  - **Duration**: User-defined period, minimum of 5 minutes.
  - **Example**: If Duration is 10 minutes, it aggregates 10 time grain values.

  - **Aggregation Method**: Can differ from time grain aggregation.
    - **Example**: 
      - Time Grain: Average CPU%
      - Duration Aggregation: Maximum of those averages over 10 minutes.

## Autoscale Actions:

- **Scale-Out**: Increases instance count.
- **Scale-In**: Reduces instance count.
- **Operators**: 
  - `>` for scale-out (when metric exceeds threshold)
  - `<` for scale-in (when metric falls below threshold)
- **Set Instance Count**: Can also directly set the number of instances.

### Cooldown Period:
- **Definition**: Time frame post-action where no new scaling occurs.
  - **Purpose**: Allows system stabilization.
  - **Minimum**: 5 minutes.

## Key Points:
- Autoscaling involves **trend analysis** over time.
- **Time Grain** helps in quick response to changes.
- **Duration** ensures that the change isn't just a blip.
- **Cooldown** prevents overreaction to temporary spikes or drops in metrics.

Remember, autoscaling is like adjusting sails on a boat; you're looking at the wind (metrics) over time, not just the gusts (momentary spikes), and you give the ship (your app) time to adjust to the new direction before making another change.

# Pairing and Combining Autoscale Rules

## **Paired Autoscale Rules**:
- **Strategy**: Define rules in pairs for both scaling out and in.
  - **Scale-Out Rule**: Triggers when metrics exceed an upper limit.
  - **Scale-In Rule**: Triggers when metrics fall below a lower limit.

## **Combining Autoscale Rules**:

### **Example Configuration**:

```markdown
- **Rules within one condition**:
  - **Scale Out**:
    - HTTP queue length > 10 â†’ Add 1 instance
    - CPU utilization > 70% â†’ Add 1 instance
  - **Scale In**:
    - HTTP queue length = 0 â†’ Remove 1 instance
    - CPU utilization < 50% â†’ Remove 1 instance
```

### **Rule Execution**:
- **Scaling Out**: Occurs if **any** of the scale-out conditions are met.
- **Scaling In**: Only happens when **all** scale-in conditions are true.

### **Separate Conditions for Different Logic**:
- If individual scale-in rules should trigger independently, they must be in **separate autoscale conditions**.

## **Key Points**:
- **Pairing**: Helps manage both increase and decrease in workload efficiently.
- **Combining**: Allows for more complex scaling behavior tailored to different scenarios.
- **Condition Logic**:
  - Use OR logic for scaling out (any condition can trigger).
  - Use AND logic for scaling in (all conditions must be met) unless specified otherwise.

Remember, with autoscaling, you're not just telling your app to grow or shrink; you're teaching it when to hibernate or when to go full Hulk mode, ensuring it's always just the right size for the task at hand.

# Enable Autoscaling in Azure App Service

## **To Start Autoscaling**:

1. **Navigate**:
   - Go to your **App Service Plan** in the Azure portal.
   - Find **Scale out (App Service plan)** under *Settings*.

### **Pricing Tier Consideration**:
- **Note**: 
  - **Development Tiers**: 
    - **F1, D1** (single instance) 
    - **B1** (manual scaling) do not support autoscaling.
  - **Action**: Upgrade to **S1 or any P-tier** for autoscaling capability.

## **Enabling Autoscaling**:

- **Default State**: Manual scaling.
- **Custom Autoscaling**: 
  - Select **Custom autoscale** to access condition groups for scaling settings.

### **Visual Guide**:

- **Azure Portal Navigation**:
  ![Azure Scale Out Settings](https://learn.microsoft.com/en-us/training/wwl-azure/scale-apps-app-service/media/enable-autoscale.png)

## **Adding Scale Conditions**:

### **Process**:
- **Default Condition**: 
  - Initially set to manual scaling, can be edited.
  - Triggered when no other conditions apply.

- **Custom Conditions**:
  - **Type**: 
    - **Metric-Based**: Scale according to resource metrics like CPU usage or HTTP queue length.
    - **Instance Count**: Set to scale to a specific number of instances.
  - **Limits**:
    - **Minimum/Maximum Instances**: Can be set, with max limited by your pricing tier.
    - **Condition Page Example**:
      ![Azure Scale Out Settings](https://learn.microsoft.com/en-us/training/wwl-azure/scale-apps-app-service/media/autoscale-conditions.png)
  - **Schedules**: 
    - Conditions can have a schedule defining active periods.

## **Key Actions**:
- **Enable**: Switch to Custom autoscale for automatic scaling.
- **Configure**: Set or edit rules for scaling behavior.
- **Monitor**: Keep track of autoscaling activity through the Azure portal.

Remember, setting up autoscaling is like tuning an instrument; you need to get the settings just right to ensure your application performs harmoniously under varying loads.

# Creating and Monitoring Scale Rules in Azure

## **Create Scale Rules**:

- **Metric-Based Scale Conditions**:
  - Include **one or more scale rules**.
  - Use **Add a rule** to define custom rules.

### **Rule Definition**:
- **Criteria**: 
  - Metrics to monitor
  - Aggregation methods (Average, Minimum, Maximum, etc.)
  - Operators (>, <, etc.)
  - Thresholds for triggering actions

- **Autoscale Action**: 
  - **Scale Out** or **Scale In** based on the rule's criteria.

### **Visual Reference**: 
- **Scale Rule Settings**:
  ![Create scale rules](https://learn.microsoft.com/en-us/training/wwl-azure/scale-apps-app-service/media/autoscale-rules.png)

## **Monitor Autoscaling Activity**:

- **Run History Chart**:
  - **Azure Portal** provides the **Run history chart** to track autoscaling events.
  - **Purpose**: 
    - Shows **instance count changes** over time.
    - Identifies **which autoscale condition** triggered each change.

### **Visual Reference**: 

- **Run History Chart**:
  ![Run History Chart](https://learn.microsoft.com/en-us/training/wwl-azure/scale-apps-app-service/media/autoscale-run-history.png)

- **Correlating with Metrics**:
  - Use the Run history alongside metrics on the **Overview page** to understand resource utilization at the time of autoscaling events.

### **Visual Reference**: 

- **Overview Metrics**:
  ![Overview Metrics](https://learn.microsoft.com/en-us/training/wwl-azure/scale-apps-app-service/media/service-plan-metrics.png)

## **Key Actions**:

- **Create**: Define rules with specific metrics and conditions for scaling.
- **Monitor**: Use Azure's tools to review and analyze autoscaling events and resource metrics.

Remember, setting up scale rules is like fine-tuning an engine; you adjust the parameters until your application runs smoothly, scaling appropriately with the demands placed upon it.

### Azure Autoscale Notes

**Autoscale Concepts:**

- **Horizontal Scaling:** 
  - **Scale Out:** Increase the number of instances when demand grows.
  - **Scale In:** Decrease the number of instances when demand reduces.
  - An autoscale setting includes:
    - **Maximum Instances:** The upper limit of instances.
    - **Minimum Instances:** The lower limit of instances.
    - **Default Instances:** The starting number of instances before any scaling occurs.

**Threshold Mechanics:**

- Autoscale operates by monitoring metrics:
  - It checks if the metric (like CPU usage) has exceeded a threshold.
  - For example:
    ```plaintext
    "scale out by one instance when average CPU > 80% when instance count is 2"
    ```
    - This means, if the average CPU usage across all instances exceeds 80% with currently 2 instances, add one more instance.

**Monitoring and Logging:**

- **Activity Log:** 
  - All scaling actions, successful or not, are logged here.
  - You can set up alerts for:
    - **Email**
    - **SMS**
    - **Webhooks**

**Best Practices:**

- **Avoid Conflicting Rules:** Ensure your autoscale rules do not counteract each other, causing unnecessary scaling actions.

These practices help in managing your resources efficiently, ensuring your systems scale appropriately with workload demands while avoiding over or under-provisioning. Remember, the last thing you want is your server farm looking like a yo-yo at a children's party â€“ up and down, up and down. Keep those scales balanced, my friend!

### Azure Autoscale Best Practices

**Setting Instance Limits:**

- **Margin Between Limits:** Ensure there's a gap between your `minimum` and `maximum` instance settings. If both are set to `2`, no scaling will occur. Here's an example:

  ```plaintext
  minimum=2
  maximum=5
  ```

**Diagnostic Metric Selection:**

- **Statistic for Scaling:** Choose from `Average`, `Minimum`, `Maximum`, or `Total` when setting up autoscale based on metrics. Typically, `Average` is used.

  ```plaintext
  metric_statistic = 'Average'
  ```

**Threshold Selection:**

- **Avoid Similar Thresholds:** Do not set autoscale thresholds too close for scale-out and scale-in. This can lead to an oscillating effect known as "flapping."

  **Bad Example:**

  ```plaintext
  scale_out_threshold = 600  # When thread count >= 600
  scale_in_threshold = 600   # When thread count <= 600
  ```

  **Better Practice:**

  ```plaintext
  scale_out_threshold = 80  # When CPU% >= 80%
  scale_in_threshold = 60   # When CPU% <= 60%
  ```

**Preventing "Flapping":**

- Autoscale uses estimation to prevent unnecessary scaling:
  - When considering scaling in, it calculates if scaling out would be immediate upon scaling in:
    
    ```plaintext
    If current CPU% is 60 across 3 instances:
    60 x 3 = 180 threads total
    180 / 2 (after scaling in) = 90 threads per instance
    ```
    - Since 90 is above the scale-out threshold, it won't scale in to avoid flapping.

**Example Scenario:**

- **Starting Point:** 2 instances
- **Scale Out:** CPU hits 80%, a third instance is added.
- **Scale In Consideration:** CPU drops to 60%, but the system estimates:
  
  ```plaintext
  60 x 3 = 180 total / 2 = 90 threads per instance after scaling in
  ```
  
  - No scale-in occurs because 90 is still near the scale-out threshold.
- **Next Check:** CPU drops further to 50%, estimation now allows scale-in:

  ```plaintext
  50 x 3 = 150 total / 2 = 75 threads per instance
  ```
  
  - Now, scaling in to 2 instances is performed as 75 is below the scale-out threshold.

**Conclusion:**

- Always ensure there's a buffer between your scale-out and scale-in thresholds to prevent rapid back-and-forth scaling actions. This not only saves resources but also keeps your system's stability in check. Remember, your servers should scale like a well-oiled machine, not like the mood swings of a teenager.

### Azure Autoscale Considerations for Multiple Rules

**Multiple Rules in a Profile:**

- **Scale-Out:** Autoscale will scale out if **any** of the scale-out rules are met.
- **Scale-In:** Autoscale will only scale in if **all** scale-in rules are satisfied.

**Example with Four Rules:**

- **Scale-Out Rules:**
  - CPU > 75%, scale out by 1
  - Memory > 75%, scale out by 1

- **Scale-In Rules:**
  - CPU < 30%, scale in by 1
  - Memory < 50%, scale in by 1

  **Scenarios:**

  - **Scale-Out Cases:**
    - CPU at 76% and Memory at 50% -> Scale out (One rule met)
    - CPU at 50% and Memory at 76% -> Scale out (One rule met)

  - **No Scale-In Cases:**
    - CPU at 25% but Memory at 51% -> No scale in (Both rules not met)

  - **Scale-In Case:**
    - CPU at 29% and Memory at 49% -> Scale in (Both rules met)

**Default Instance Count:**

- **Importance:** Set a safe default instance count. This count is used when metrics are unavailable for scaling decisions.
  - **Example:**

    ```plaintext
    default_instance_count = 3  # Choose based on minimal safe operation level
    ```

**Autoscale Notifications:**

- **Activity Log:** Autoscale logs these events:
  - When it issues a scale operation.
  - Successful completion of a scale action.
  - Failure to scale.
  - When metrics are unavailable or become available again.

- **Setting Up Alerts:**
  - Use Activity Log alerts to monitor the autoscale engine's health.
  - Configure notifications for successful scale actions:
    
    ```plaintext
    notifications {
      email: ["admin@example.com", "support@example.com"],
      webhook: "https://example.com/autoscale-webhook"
    }
    ```

**Conclusion:**

- When configuring multiple rules, remember that scale-out is more lenient while scale-in requires all conditions to be met to avoid unnecessary scaling. Ensure your default instance count is set to handle your workload safely when metrics fail. And don't forget to set up notifications; it's always good to know when your system decides to grow or shrink, just like keeping tabs on whether your garden needs watering or not.

### Azure App Service Deployment Slots Overview

**What are Deployment Slots?**

- Deployment slots in Azure App Service provide a staging environment where you can deploy your app before swapping it into production. This minimizes downtime and risk during application updates.

**Key Concepts:**

- **Slot Swapping:** The process of switching the environment (staging to production or vice versa) without downtime.

- **Manual Traffic Routing:** Allows you to control the flow of traffic to different slots for testing purposes.

- **Automatic Traffic Routing:** Can be set up to automatically route traffic based on certain conditions or rules.

**How Slot Swapping Works:**

- When you swap slots:
  1. The staging slot's content becomes the new production content.
  2. The old production content moves to the staging slot, allowing for rollback if necessary.

  ```plaintext
  # Pseudocode for a slot swap
  swap_slots(sourceSlotName="staging", targetSlotName="production")
  ```

**Manual Traffic Routing:**

- You can manually route traffic to test new features or changes in a staging environment.

  ```plaintext
  # Example of routing 50% of traffic to staging
  set_traffic_route(productionSlot="production", stagingSlot="staging", percentage=50)
  ```

**Automatic Traffic Routing:**

- Automate traffic based on conditions like:
  - Time of day (e.g., sending more traffic to staging during low-traffic hours).
  - Performance metrics (if staging performs better, gradually shift more traffic).

  ```plaintext
  # Example of setting up an automatic rule
  add_automatic_routing_rule(condition="timeOfDay", startTime="22:00", endTime="06:00", targetSlot="staging")
  ```

**Benefits of Using Slots:**

- **Zero Downtime Deployment:** Swap environments without taking the app offline.
- **Easy Rollback:** If something goes wrong, swap back to the previous state.
- **Testing in Production:** Test new versions with real-world data and traffic patterns.

**Steps to Perform a Swap:**

1. **Deploy:** Push your new version to a staging slot.
2. **Test:** Validate in the staging environment.
3. **Swap:** Use Azure portal or CLI to swap the slots.

   ```plaintext
   # CLI command for slot swapping
   az webapp deployment slot swap --resource-group MyResourceGroup --name MyWebApp --slot staging
   ```

**Conclusion:**

Deployment slots in Azure App Service are your magic wand for seamless application updates. They allow you to experiment in a production-like setting without affecting your live website, ensuring that your app deployment is as smooth as a jazz tune. Remember, with great power comes great responsibilityâ€”use slots wisely to avoid any production blues.

### Azure App Service Deployment Slots Introduction

**Overview:**

- Deployment slots in Azure App Service facilitate a robust environment for managing application versions, allowing developers to stage, test, and deploy updates with minimal risk.

**Learning Objectives:**

- **Understand Benefits:** Learn why using deployment slots is advantageous for application management.
- **Slot Swapping:** Grasp the mechanism behind swapping slots in App Service.
- **Manual vs Auto Swap:** Know how to manually swap slots and set up auto-swapping.
- **Traffic Management:** Learn techniques for routing traffic both manually and automatically.

**Key Points:**

- **Benefits of Deployment Slots:**
  - **Zero-downtime deployments**: Update your app without interrupting service.
  - **Testing in Production Environment**: Test with real user traffic without affecting the live app.
  - **Easy Rollback**: Revert changes by swapping back if issues arise post-deployment.

- **Slot Swapping Mechanics:**
  - Swap operation moves the content from one slot (usually staging) to another (production).
  - Example swap command:

    ```plaintext
    az webapp deployment slot swap --resource-group MyResourceGroup --name MyWebApp --slot staging
    ```

- **Manual Swap and Auto Swap:**
  - **Manual Swap:** Directly control when to swap using the Azure portal, CLI, or API.
  - **Auto Swap:** Configure auto-swapping to occur when certain conditions are met, like after successful deployment.

    ```plaintext
    # Enable auto swap for a slot
    az webapp deployment slot auto-swap --name MyWebApp --resource-group MyResourceGroup --slot staging --enable
    ```

- **Traffic Routing:**
  - **Manual Routing:** Use for A/B testing, where you control how much traffic goes to each slot.

    ```plaintext
    # Route 30% traffic to staging slot
    az webapp traffic-routing set --name MyWebApp --resource-group MyResourceGroup --distribution staging=30 production=70
    ```

  - **Automatic Routing:** Set rules or use Azure Traffic Manager for dynamic traffic distribution based on performance or other metrics.

**Prerequisites:**

- Prior experience with Azure portal to ensure you're familiar with managing App Service web apps.

**Conclusion:**

Deployment slots are like having a safety net for your app updates, allowing you to juggle different versions of your application with the finesse of a circus performer. This module sets you up to not only manage your app's lifecycle with ease but also to do it with the confidence of knowing you can always catch your app with the net if it falls.

### Staging Environments in Azure App Service

**Overview:**

- Deployment slots are available in Standard, Premium, and Isolated tiers, allowing deployment to environments other than the default production slot.

**Benefits of Using Staging Slots:**

- **Pre-Deployment Testing:** Validate changes before they hit production.
  
  ```plaintext
  // Pseudo-code for deploying to a staging slot
  deploy_to_slot(appName="MyWebApp", slotName="staging", source="dev-branch")
  ```

- **Warm-Up:** Ensures all instances of the slot are warmed up before going live, avoiding downtime:

  ```plaintext
  # Pseudo-code for warming up instances
  warm_up_instances(slotName="staging")
  ```

- **Seamless Traffic Redirection:** Swapping slots redirects traffic instantly without losing requests.

- **Rollback Capability:** Swap back to the previous version if something goes wrong:

  ```plaintext
  # Pseudo-code for rollback
  swap_slots(sourceSlot="production", targetSlot="staging")
  ```

- **Automation:** Auto-swap can be configured for immediate production deployment post-validation.

  ```plaintext
  # Pseudo-code to enable auto-swap
  enable_auto_swap(slotName="staging")
  ```

**Slot Management:**

- **Slot Limitations:** 
  - Each tier supports a different number of slots. Check App Service limits for your tier's capacity.
  - Scaling down requires the new tier to support the current slot number.

**Slot Creation and Configuration:**

- **Content:** New slots start empty but can be cloned from another slot for settings.
  
  ```plaintext
  # Pseudo-code to clone settings from production
  clone_slot_settings(productionSlot="production", newSlot="staging")
  ```

- **Deployment:** Deploy different versions or branches to staging slots for testing.

**Important Notes:**

- When scaling your app, ensure the target tier supports your current slot usage. For instance, Standard tier supports up to five slots.

- Deployment slots provide a safe playground for your app's updates. Think of them as your app's dress rehearsal room where it can perform without the audience until it's showtime in production.

### Slot Swapping in Azure App Service

**Slot Swapping Process:**

1. **Configuration Application:**
   - Apply settings from the target slot (e.g., production) to the source slot (e.g., staging):
     - Slot-specific settings like app settings and connection strings.
     - Continuous deployment settings.
     - App Service authentication settings.
     
     ```plaintext
     # Pseudo-code for applying settings
     apply_target_settings(sourceSlot="staging")
     ```

   - This triggers a restart of all instances in the source slot.

2. **Restart Validation:**
   - Wait for all instances in the source slot to restart successfully. If an instance fails, the swap reverts.

3. **Local Cache Initialization:**
   - If local cache is enabled, an HTTP request to `/` on each instance initializes the cache, causing another restart.

   ```plaintext
   # Pseudo-code for local cache initialization
   init_local_cache(slot="staging")
   ```

4. **Application Warm-Up:**
   - If auto swap with custom warm-up is enabled, hit `/` to warm up the application:

   ```plaintext
   # Pseudo-code for application warm-up
   warm_up_application(slot="staging")
   ```

5. **Swap Execution:**
   - Once all instances are warmed up, swap the routing rules of the slots:

   ```plaintext
   # Pseudo-code for executing the swap
   execute_slot_swap(sourceSlot="staging", targetSlot="production")
   ```

6. **Post-Swap Actions:**
   - Apply the original target slot's settings to what is now the new source slot, ensuring consistency.

**Key Considerations:**

- **No Downtime:** The target slot remains online during the swap process, ensuring no downtime for production.
- **Swap Direction:** Always swap into the production slot as the target to minimize impact on live traffic.
- **Configuration Cloning:** When cloning config, remember:
  - **Content-Following Settings:** These settings move with the app during a swap.
  - **Slot-Specific Settings:** These stay with their respective slots after a swap.

**Configuration Elements During Swap:**

- **App Settings:** Slot specific unless marked to stick with content.
- **Connection Strings:** Similar to app settings, can be configured to follow content or remain slot-specific.
- **Publishing Profile:** Stays with the slot.

**Conclusion:**

Slot swapping in Azure is like performing a magic trick. You wave your wand (execute the swap), and suddenly your staging slot's content appears in production without the audience (your users) noticing any downtime. Just make sure you've got your hat (configuration) straight before pulling the rabbit (your app) out.

### Configuration Settings in Azure App Service Slot Swapping

**Swappable vs. Non-Swappable Settings:**

- **Settings That Are Swapped:**
  - General settings like framework version, 32/64-bit architecture, and WebSockets.
  - **App Settings:** Can be configured to stick to a slot or follow content to a new slot.
  
    ```plaintext
    # Example of an app setting that follows content
    WEBSITE_NODE_DEFAULT_VERSION=12.13.0
    ```
  
  - **Connection Strings:** Similar to app settings, can be set to stick to a slot or swap with the app.
    
    ```plaintext
    # Example of a connection string
    SQLAZURECONNSTR_defaultConnection=Server=tcp:servername.database.windows.net,1433;Database=databaseName;User ID=userName;Password=password;Trusted_Connection=False;Encrypt=True;
    ```
    
  - Handler mappings.
  - Public certificates.
  - WebJobs content.
  - Path mappings.

- **Settings That Aren't Swapped:**
  - Publishing endpoints.
  - Custom domain names.
  - Non-public certificates and TLS/SSL settings.
  - Scale settings.
  - WebJobs schedulers.
  - IP restrictions.
  - Always On settings.
  - **Azure Content Delivery Network** (planned to be unswapped).
  - **Service Endpoints** (planned to be unswapped).
  - Diagnostic log settings.
  - Cross-origin resource sharing (CORS).
  - Virtual network integration.
  - Managed identities.
  - Settings ending with `_EXTENSION_VERSION`.

**Making Settings Swappable:**

- To override the default behavior where certain settings are sticky to slots:
  
  ```plaintext
  # App setting to override sticky slot settings
  WEBSITE_OVERRIDE_PRESERVE_DEFAULT_STICKY_SLOT_SETTINGS=0
  ```

  This setting should be added to every slot. Setting it to `0` or `false` makes all settings swappable.

**Configuring Slot-Specific Settings:**

- To make an app setting or connection string slot-specific (not swappable):
  - Navigate to the slot's **Configuration** page.
  - Add or edit the setting.
  - Check the **Deployment slot setting** box.

    ```plaintext
    # Setting a slot-specific app setting (example)
    APPSETTING_DEBUG=true [Deployment Slot Setting]
    ```

**Note:**

- Managed identities are always slot-specific and are not affected by the override setting.

**Conclusion:**

In Azure App Service, you can tailor how settings behave during slot swaps, giving you the flexibility to keep certain configurations consistent across environments while allowing others to adapt. Think of it like setting the stage: you want the backdrop (slot-specific settings) to remain, but you're swapping the actors (your app) and their props (content and swappable settings) for a new scene.

### Manual Slot Swapping in Azure App Service

**Steps to Swap Deployment Slots:**

1. **Access the Deployment Slots Page:**
   - Navigate to your app in Azure portal, then to the **Deployment slots** page.

2. **Initiate Swap:**
   - Click on **Swap** to open the swap dialog.

     ```plaintext
     # Pseudo-code for initiating a swap
     initiate_swap(sourceSlot="staging", targetSlot="production")
     ```

3. **Select Slots:**
   - Choose **Source** (e.g., staging) and **Target** (typically production) slots. Verify settings in both tabs:
     - **Source Changes:** Settings that will be applied to the source slot.
     - **Target Changes:** Settings that will be applied to the target slot post-swap.

4. **Immediate Swap:**
   - If you're ready to swap without preview, click **Swap** to execute the operation.

5. **Swap with Preview:**
   - For validation, check the **Perform swap with preview** option. This begins a multi-phase swap:
   
     - **Phase 1:** Applies the target slot's settings to the source slot, then pauses.
     
       ```plaintext
       # Pseudo-code for starting the swap with preview
       start_swap_with_preview(sourceSlot="staging", targetSlot="production")
       ```

     - **Preview:** Visit the source slot URL to test the app with new settings:
     
       ```plaintext
       # URL format for previewing the swap
       https://<app_name>-<source-slot-name>.azurewebsites.net
       ```

     - **Phase 2:** If satisfied with the preview, select **Complete Swap** to finalize the swap.

     ```plaintext
     # Pseudo-code for completing the swap
     complete_swap()
     ```

   - **Cancel:** If issues are found during the preview, select **Cancel Swap** to revert changes.

6. **Close Dialog:**
   - After the swap or cancellation, click **Close** to exit the swap interface.

**Key Points:**

- **Validation:** Always ensure the production slot is the target to minimize downtime.
- **Configuration Review:** Review settings in both slots before proceeding with the swap.
- **Warm-Up:** Swap with preview ensures the source slot is warmed up, reducing the risk of performance issues.
- **Rollback:** If a swap with preview is canceled, the configuration reverts, providing a safety net.

**Conclusion:**

Swapping deployment slots in Azure App Service is like changing the soup of the day in a restaurant's menu - you want to make sure the new flavor (staging environment) is just right before serving it to all the patrons (your production users). With the option to preview, you can taste the soup before making it the special of the day, ensuring it's a hit.

### Configuring Auto Swap in Azure App Service

**Steps to Enable Auto Swap:**

1. **Navigate to the Slot Configuration:**
   - Go to your App Service's resource page in Azure portal.
   - Click on the deployment slot you're configuring for auto swap.

2. **Enable Auto Swap:**
   - Go to **Configuration** > **General settings**.
   - Turn **Auto swap enabled** to **On** and select the **target slot** for auto swap.

     ```plaintext
     # Pseudo-code for enabling auto swap
     enable_auto_swap(sourceSlot="staging", targetSlot="production")
     ```

   - Save the changes.

3. **Code Push:**
   - Push your code to the source slot. Auto swap will occur automatically post-warm-up.

**Custom Warm-Up Configuration:**

- **Using `web.config`:**
  - Insert `<applicationInitialization>` within `<system.webServer>` to specify custom warm-up actions.

    ```xml
    <system.webServer>
        <applicationInitialization>
            <add initializationPage="/" hostName="[app hostname]" />
            <add initializationPage="/Home/About" hostName="[app hostname]" />
        </applicationInitialization>
    </system.webServer>
    ```

- **App Settings for Customization:**

  - **WEBSITE_SWAP_WARMUP_PING_PATH:** Custom URL path to ping for warm-up.

    ```plaintext
    # Setting custom warm-up path
    WEBSITE_SWAP_WARMUP_PING_PATH=/statuscheck
    ```

  - **WEBSITE_SWAP_WARMUP_PING_STATUSES:** HTTP status codes considered valid for warm-up.

    ```plaintext
    # Setting valid HTTP status codes for warm-up
    WEBSITE_SWAP_WARMUP_PING_STATUSES=200,202
    ```

  - **WEBSITE_WARMUP_PATH:** Path to ping on site restarts.

    ```plaintext
    # Setting warm-up path for restarts
    WEBSITE_WARMUP_PATH=/statuscheck
    ```

**Notes:**

- **Linux and Containers:** Auto swap is not supported for web apps on Linux or Web App for Containers.
- **Troubleshooting:** For issues with auto swap or warm-up, refer to deployment slot swap failures documentation.

**Conclusion:**

Configuring auto swap in Azure App Service is like setting up a conveyor belt in a factory. Once your app's code is pushed, it automatically rolls into production, ensuring zero downtime and cold starts. Custom warm-up settings ensure the machinery (your app) is fully operational before it hits the production line, keeping your customers (users) satisfied with smooth service transitions.

### Rollback and Monitoring Slot Swaps in Azure App Service

**Rollback Procedure:**

- **Immediate Swap Back:** If issues arise post-swap:

  ```plaintext
  # Pseudo-code for immediate rollback
  swap_slots(sourceSlot="production", targetSlot="staging")
  ```

  This command effectively swaps the slots back to their original configurations.

**Monitoring the Swap Operation:**

1. **Access the Activity Log:**
   - In the Azure portal, navigate to your app's resource page.
   - From the left pane, select **Activity Log**.

2. **Check Swap Operations:**
   - Look for **Swap Web App Slots** in the activity log entries. This can help you understand:
     - Duration of the swap operation.
     - Any errors or suboperations that occurred.

   ```plaintext
   # Pseudo-code to filter for swap operations in logs
   filter_activity_log(event='Swap Web App Slots')
   ```

3. **Detail Examination:**
   - Click on the swap event to expand it, where you can:
     - Review suboperations.
     - Access error details if the swap didn't complete as expected.

**Conclusion:**

Rollback in Azure App Service is like hitting an "undo" button for your environment swap. If the new production setup doesn't perform as expected, a quick re-swap can bring back the previous version while you investigate. Monitoring through the activity log is akin to reviewing the flight recorder after a flight; it helps you understand what happened during the swap journey, ensuring you can troubleshoot or optimize future swaps.

### Routing Traffic in Azure App Service

**Traffic Routing Overview:**

- By default, all traffic goes to the production slot. However, Azure allows you to route traffic to different slots for testing or phased rollouts.

**Steps for Automatic Traffic Routing:**

1. **Navigate to Deployment Slots:**
   - Go to your app's **Deployment slots** section in the Azure portal.

2. **Set Traffic Percentage:**
   - In the **Traffic %** column for the desired slot (e.g., staging):
     - Enter a percentage (0-100) of traffic to be routed to this slot.
     - Click **Save**.

     ```plaintext
     # Pseudo-code for setting traffic distribution
     set_traffic_percentage(slotName="staging", percentage=10)
     ```

3. **Client Routing:**
   - After saving, the specified percentage of traffic will be randomly routed to the slot.
   - Clients are **pinned** to the slot for their session duration, determined by the `x-ms-routing-name` cookie.

**Example of Traffic Distribution:**

- If you set **staging** to receive 10% of the traffic:
  - 10% of users will be directed to the staging environment.
  - They will receive this cookie: `x-ms-routing-name=staging`
  - The remaining 90% will go to production with `x-ms-routing-name=self`.

**Checking Slot Assignment:**

- Use the `x-ms-routing-name` cookie from HTTP headers to confirm which slot your session is using.

**Conclusion:**

Routing traffic in Azure App Service is like directing a small portion of your audience to a different theater for a sneak preview. You get real user feedback without committing the entire audience. By controlling the traffic percentage, you can test updates safely, and the sticky session ensures users stay with their assigned slot throughout their visit, providing a consistent experience for testing purposes.

### Manual Traffic Routing in Azure App Service

**Manual Traffic Routing with Query Parameters:**

- Azure App Service allows routing traffic manually to different slots using the `x-ms-routing-name` query parameter.

**Opting Out of Beta:**

- To return users to the production environment from a beta or testing slot:

```html
<a href="<webappname>.azurewebsites.net/?x-ms-routing-name=self">Go back to production app</a>
```

- This link sets the `x-ms-routing-name` to **self**, directing the user to the production slot. Subsequent requests include this cookie, keeping the user in production for the session.

**Opting Into Beta:**

- To direct users to a non-production slot (like staging):

```html
<webappname>.azurewebsites.net/?x-ms-routing-name=staging
```

- Replace `staging` with your slot's name.

**Advanced Traffic Control:**

- When setting a slot's traffic percentage to **0%**:
  - The **0%** value in black indicates that the slot is not automatically routing traffic, but manual access via the query parameter is still possible.
  - This setup is useful for hiding the slot from public traffic while allowing specific users or internal teams to access it for testing.

**Key Points:**

- **Manual Routing:** Useful for beta testing where users can opt in or out.
- **Cookie Persistence:** Once a user is routed, the session is "pinned" to that slot via a cookie.
- **Slot Visibility:** Setting traffic to 0% hides the slot from random routing but allows manual access.

**Conclusion:**

Manual traffic routing with Azure App Service is like having a secret handshake. You can give users the option to see behind the curtain (beta environment) or return to the main stage (production) without interrupting the overall show. It's a clever way to get targeted feedback or to conduct controlled testing without throwing open the doors to everyone.