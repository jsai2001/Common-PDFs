Below is a comprehensive list of Python interview preparation questions, covering a wide range of topics from basics to advanced concepts. I've categorized them to help you focus on specific areas depending on the role or your preparation needs. These questions span technical knowledge, problem-solving, and practical coding scenarios commonly encountered in interviews.

### 1. Python Basics
- What is Python, and what are its key features?
- Explain the difference between Python 2 and Python 3.
- What are PEP 8 guidelines, and why are they important?
- How is Python an interpreted language?
- What are the differences between lists, tuples, and sets in Python?
- What is the difference between `==` and `is` in Python?
- How does Python handle memory management?
- What are mutable and immutable objects in Python? Give examples.
- What is the purpose of the `pass` statement?
- How do you swap two variables in Python without using a temporary variable?
- What are Python’s built-in data types?
- What is the difference between `range()` and `xrange()` (Python 2 vs. Python 3 context)?
- What is a Python module, and how do you import one?
- Explain the `if __name__ == "__main__":` idiom.
- What are `*args` and `**kwargs`, and how are they used?

### 2. Strings and Text Processing
- How do you reverse a string in Python?
- What is string slicing, and how does it work?
- How do you check if a string is a palindrome?
- Explain the difference between `str.join()` and `str.format()`.
- How do you convert a string to lowercase or uppercase?
- What is the difference between `find()` and `index()` in strings?
- How would you remove leading and trailing whitespace from a string?
- How do you count the occurrences of a substring in a string?
- What are f-strings, and how do they compare to older string formatting methods?
- How do you split a string into a list of words?

### 3. Lists, Dictionaries, and Sets
- How do you remove duplicates from a list?
- What is list comprehension, and how does it work? Provide an example.
- How do you sort a list of dictionaries by a specific key?
- What is the difference between `append()` and `extend()` in lists?
- How do you merge two dictionaries in Python?
- What is the difference between `pop()` and `remove()` in lists?
- How do you check if a key exists in a dictionary?
- What are dictionary comprehensions? Provide an example.
- How do set operations like union, intersection, and difference work in Python?
- How would you flatten a nested list in Python?

### 4. Functions and Functional Programming
- What is a lambda function, and when would you use it?
- Explain the difference between `map()`, `filter()`, and `reduce()`.
- How do you define default arguments in a function?
- What is recursion, and how do you implement it in Python?
- How does Python handle variable scope (LEGB rule)?
- What are decorators, and how do you create one?
- How do you pass a function as an argument to another function?
- What is the difference between a shallow copy and a deep copy?
- How do you handle exceptions in a function?
- What is the purpose of the `global` keyword?

### 5. Object-Oriented Programming (OOP)
- What are the key principles of OOP in Python?
- What is the difference between a class and an object?
- How do you implement inheritance in Python?
- What is method overriding, and how does it work?
- Explain the difference between `self` and `cls` in Python.
- What are static methods and class methods? How do you define them?
- What is polymorphism in Python? Provide an example.
- How do you implement encapsulation in Python?
- What is the purpose of the `__init__` method?
- What are abstract base classes (ABCs), and how do you use them?

### 6. Data Structures and Algorithms
- How would you implement a stack in Python?
- How would you implement a queue in Python?
- What is a binary search, and how do you implement it?
- How do you reverse a linked list in Python?
- What is the time complexity of common Python list operations (e.g., append, pop, insert)?
- How do you find the maximum element in a list without using `max()`?
- How would you implement a hash table in Python?
- What is a heap, and how can you use the `heapq` module?
- How do you detect a cycle in a linked list?
- Explain the difference between breadth-first search (BFS) and depth-first search (DFS).

### 7. File Handling
- How do you read a file line by line in Python?
- What is the difference between `read()`, `readline()`, and `readlines()`?
- How do you write to a file in Python?
- What is the purpose of the `with` statement when working with files?
- How do you append data to an existing file?
- How do you handle file exceptions (e.g., `FileNotFoundError`)?
- How do you read and write CSV files in Python?
- How do you work with JSON files in Python?
- What is the difference between binary and text file modes?
- How do you delete a file using Python?

### 8. Modules and Libraries
- What is the difference between `import module` and `from module import *`?
- How do you install a third-party library using `pip`?
- What is the purpose of the `sys` module?
- How do you generate random numbers using the `random` module?
- What is the `datetime` module, and how do you use it?
- How do you use the `os` module to interact with the operating system?
- What is `numpy`, and how does it differ from Python lists?
- How do you create a virtual environment in Python?
- What is the purpose of the `collections` module?
- How do you use the `re` module for regular expressions?

### 9. Exception Handling
- What is exception handling, and why is it important?
- How do you use `try`, `except`, `else`, and `finally` blocks?
- How do you raise a custom exception in Python?
- What is the difference between an error and an exception?
- How do you catch multiple exceptions in a single `except` block?
- What happens if an exception is not handled?
- How do you log exceptions using the `logging` module?
- What is the purpose of the `assert` statement?
- How do you handle a `KeyError` in a dictionary?
- What is the difference between `sys.exit()` and raising an exception?

### 10. Advanced Python
- What are generators, and how do they differ from regular functions?
- How do you create a generator using the `yield` keyword?
- What is a context manager, and how do you implement one?
- What are metaclasses in Python?
- How does multithreading work in Python with the GIL (Global Interpreter Lock)?
- What is the difference between multiprocessing and multithreading?
- How do you use the `asyncio` library for asynchronous programming?
- What are closures, and how do they work in Python?
- How do you profile a Python program for performance?
- What is the difference between `__str__` and `__repr__`?

### 11. Coding Problems
- Write a Python program to find the factorial of a number.
- Write a function to check if a number is prime.
- Implement a function to find the Fibonacci sequence up to `n` terms.
- Write a program to find the second largest number in a list.
- How would you merge two sorted lists into a single sorted list?
- Write a function to remove all vowels from a string.
- Implement a binary search tree in Python.
- Write a program to find all anagrams in a list of strings.
- How do you find the longest common substring between two strings?
- Write a function to rotate a list by `k` positions.

### 12. Practical/Scenario-Based Questions
- How would you optimize a Python script that processes large datasets?
- How do you debug a Python program effectively?
- What steps would you take to handle memory leaks in Python?
- How would you design a simple REST API using Python (e.g., with Flask)?
- How do you unit test Python code using `unittest` or `pytest`?
- How would you process a large CSV file without loading it entirely into memory?
- How do you handle concurrency in a Python web application?
- What approach would you take to scrape a website using Python?
- How would you implement a simple caching mechanism in Python?
- How do you deploy a Python application to production?

1. **What is Python, and what are its key features?**
    - **Answer:**
      Python is a high-level, interpreted, general-purpose programming language known for its readability and simplicity. Created by Guido van Rossum and first released in 1991, it supports multiple programming paradigms like procedural, object-oriented, and functional programming.
      - **Key Features:**
         - Readable Syntax: Code is easy to read and write, resembling English-like statements.
         - Interpreted: Executes code line-by-line, making debugging easier.
         - Dynamically Typed: No need to declare variable types explicitly.
         - Extensive Standard Library: Offers a wide range of modules and packages for tasks like file I/O, networking, and more.
         - Cross-Platform: Runs on Windows, macOS, Linux, etc.
         - Supports Multiple Paradigms: Allows procedural, OOP, and functional programming.
         - Garbage Collection: Automatically manages memory.
         - Community Support: Has a large, active community and ecosystem (e.g., NumPy, Django).

2. **Explain the difference between Python 2 and Python 3.**
    - **Answer:**
      Python 2 and Python 3 are two major versions of Python, with Python 3 being the current, actively maintained version (Python 2 reached end-of-life in January 2020).
      - **Key Differences:**
         - Print Statement: Python 2 uses `print "Hello"` (statement), while Python 3 uses `print("Hello")` (function).
         - Integer Division: In Python 2, `5 / 2` returns `2` (integer); in Python 3, it returns `2.5` (float).
         - Unicode Support: Python 3 has native Unicode support for strings (default), while Python 2 treats strings as ASCII unless explicitly declared as Unicode with `u"string"`.
         - `xrange` vs `range`: Python 2 has `xrange()` for memory-efficient iteration; Python 3 replaces it with an improved `range()`.
         - Syntax Improvements: Python 3 introduces features like f-strings, keyword-only arguments, and better exception handling.
         - Library Support: Python 3 has modern libraries; many Python 2 libraries are no longer maintained.

3. **What are PEP 8 guidelines, and why are they important?**
    - **Answer:**
      PEP 8 is Python’s official style guide, written by Guido van Rossum, Barry Warsaw, and Nick Coghlan. It provides conventions for writing clean, readable Python code.
      - **Key Guidelines:**
         - Use 4 spaces for indentation (no tabs).
         - Limit lines to 79 characters.
         - Use snake_case for variables/functions and CamelCase for classes.
         - Add a space around operators (e.g., `x = 1` not `x=1`).
         - Include docstrings for modules, classes, and functions.
      - **Importance:**
         - Enhances code readability and consistency, especially in collaborative projects.
         - Reduces errors caused by poor formatting.
         - Aligns with community standards, making code more maintainable.

4. **How is Python an interpreted language?**
    - **Answer:**
      Python is an interpreted language because it executes code line-by-line without requiring a separate compilation step. When you run a Python script, the interpreter reads the source code, converts it to bytecode (an intermediate representation), and then executes it in the Python Virtual Machine (PVM).
      - **Process:**
         - Source code (e.g., `script.py`) is written.
         - The Python interpreter compiles it to bytecode (`.pyc` files).
         - The PVM executes the bytecode.
      Unlike compiled languages (e.g., C), Python doesn’t produce a standalone executable, making it slower but easier to debug and portable across platforms.

5. **What are the differences between lists, tuples, and sets in Python?**
    - **Answer:**
      - **Lists:** Ordered, mutable collections defined with square brackets `[1, 2, 3]`. You can add, remove, or modify elements (e.g., `append()`, `pop()`). Duplicates are allowed.
      - **Tuples:** Ordered, immutable collections defined with parentheses `(1, 2, 3)`. Once created, elements cannot be changed. Faster than lists due to immutability. Duplicates are allowed.
      - **Sets:** Unordered, mutable collections defined with curly braces `{1, 2, 3}` or `set()`. Automatically removes duplicates. Supports mathematical operations like union and intersection.
      - **Example:**
         ```python
         list_example = [1, 2, 2]  # Mutable, ordered, duplicates OK
         tuple_example = (1, 2, 2) # Immutable, ordered, duplicates OK
         set_example = {1, 2}      # Mutable, unordered, no duplicates
         ```

6. **What is the difference between `==` and `is` in Python?**
    - **Answer:**
      - `==`: Compares the values of two objects for equality. It checks if the contents are the same.
      - `is`: Compares the identity of two objects. It checks if they refer to the same memory location (same object).
      - **Example:**
         ```python
         a = [1, 2, 3]
         b = [1, 2, 3]
         print(a == b)  # True (same values)
         print(a is b)  # False (different objects)
         c = a
         print(a is c)  # True (same object)
         ```

7. **How does Python handle memory management?**
    - **Answer:**
      Python uses automatic memory management through:
      - **Reference Counting:** Each object has a count of references pointing to it. When the count drops to zero, the memory is freed.
      - **Garbage Collector:** Handles cyclic references (e.g., objects referencing each other) that reference counting can’t resolve. The `gc` module manages this.
      - **Memory Allocation:** Python’s memory manager (part of CPython) allocates memory in pools and arenas for efficiency.
      - **Example:**
         ```python
         x = [1, 2, 3]  # Reference count = 1
         y = x          # Reference count = 2
         del y          # Reference count = 1
         del x          # Reference count = 0, memory freed
         ```

8. **What are mutable and immutable objects in Python? Give examples.**
    - **Answer:**
      - **Mutable Objects:** Can be changed after creation. Modifications affect the original object. Examples:
         - Lists: `[1, 2, 3]` (can append, remove).
         - Dictionaries: `{"a": 1}` (can add/remove keys).
         - Sets: `{1, 2, 3}` (can add/remove elements).
      - **Immutable Objects:** Cannot be changed after creation. Any modification creates a new object. Examples:
         - Integers: `5` (changing value creates a new integer).
         - Strings: `"hello"` (e.g., `upper()` returns a new string).
         - Tuples: `(1, 2, 3)` (cannot modify elements).
      - **Example:**
         ```python
         x = [1, 2]  # Mutable
         x.append(3) # x is now [1, 2, 3]
         y = "hi"    # Immutable
         y = y + "!" # y is now "hi!", new object created
         ```

9. **What is the purpose of the `pass` statement?**
    - **Answer:**
      The `pass` statement is a null operation in Python. It acts as a placeholder where code is syntactically required but you don’t want any action to occur. It’s often used in empty loops, functions, or classes during development.
      - **Example:**
         ```python
         def func():
              pass  # To be implemented later

         for i in range(5):
              if i == 3:
                    pass  # Do nothing
              else:
                    print(i)
         ```

10. **How do you swap two variables in Python without using a temporary variable?**
     - **Answer:**
        In Python, you can swap two variables using tuple unpacking in a single line:
        ```python
        a, b = 5, 10
        a, b = b, a  # Now a = 10, b = 5
        ```
        This works because Python evaluates the right-hand side first, creates a tuple `(b, a)`, and then unpacks it into `a, b`. No temporary variable is needed.

11. **What are Python’s built-in data types?**
     - **Answer:**
        Python’s built-in data types include:
        - **Numeric:** `int` (e.g., `5`), `float` (e.g., `3.14`), `complex` (e.g., `3+4j`).
        - **Sequence:** `str` (e.g., `"hello"`), `list` (e.g., `[1, 2]`), `tuple` (e.g., `(1, 2)`).
        - **Mapping:** `dict` (e.g., `{"key": "value"}`).
        - **Set:** `set` (e.g., `{1, 2}`), `frozenset` (immutable set).
        - **Boolean:** `bool` (`True`, `False`).
        - **NoneType:** `None` (represents absence of a value).

12. **What is the difference between `range()` and `xrange()` (Python 2 vs. Python 3 context)?**
     - **Answer:**
        - **Python 2:** `range()` returns a list of numbers, while `xrange()` returns an iterator (more memory-efficient for large ranges).
        - **Python 3:** `range()` is the only option and behaves like Python 2’s `xrange()`, returning a range object (iterator). `xrange()` no longer exists.
        - **Example:**
          ```python
          # Python 3
          r = range(5)  # range(0, 5), an iterator
          print(list(r))  # [0, 1, 2, 3, 4]
          ```

13. **What is a Python module, and how do you import one?**
     - **Answer:**
        A Python module is a file containing Python code (e.g., functions, classes, variables) that can be reused in other programs.
        - **How to Import:**
          - `import module_name`: Imports the entire module.
          - `from module_name import item`: Imports a specific item (e.g., function).
          - `import module_name as alias`: Imports with an alias.
        - **Example:**
          ```python
          import math
          print(math.sqrt(16))  # 4.0

          from math import pi
          print(pi)  # 3.14159
          ```

14. **Explain the `if __name__ == "__main__":` idiom.**
     - **Answer:**
        The `if __name__ == "__main__":` idiom ensures code inside it runs only if the script is executed directly, not when imported as a module. `__name__` is a built-in variable:
        - Set to `"__main__"` when the script is run directly.
        - Set to the module’s name when imported.
        - **Example:**
          ```python
          # my_script.py
          def func():
                print("Function called")

          if __name__ == "__main__":
                func()  # Runs only if script is executed directly
          ```

15. **What are `*args` and `**kwargs`, and how are they used?**
     - **Answer:**
        - `*args`: Allows a function to accept a variable number of positional arguments as a tuple.
        - `**kwargs`: Allows a function to accept a variable number of keyword arguments as a dictionary.
        - **Example:**
          ```python
          def example(*args, **kwargs):
                print("Positional args:", args)
                print("Keyword args:", kwargs)

          example(1, 2, 3, name="Alice", age=25)
          # Output:
          # Positional args: (1, 2, 3)
          # Keyword args: {'name': 'Alice', 'age': 25}
          ```

16. **How do you reverse a string in Python?**  
**Answer:**  
There are several ways to reverse a string in Python:  
- **Using Slicing:** The most Pythonic way is `string[::-1]`.  
    ```python
    s = "hello"
    print(s[::-1])  # "olleh"
    ```
- **Using `reversed()`:** Returns an iterator, which can be joined back into a string.  
    ```python
    s = "hello"
    print("".join(reversed(s)))  # "olleh"
    ```
The slicing method (`[::-1]`) is preferred for its simplicity and readability.

17. **What is string slicing, and how does it work?**  
**Answer:**  
String slicing is a technique to extract a substring using the syntax `string[start:stop:step]`.  
- `start`: Starting index (inclusive).  
- `stop`: Ending index (exclusive).  
- `step`: Increment between indices (default is 1).  
Example:  
    ```python
    s = "Python"
    print(s[0:2])    # "Py" (start=0, stop=2)
    print(s[2:])     # "thon" (from index 2 to end)
    print(s[::-1])   # "nohtyP" (reverse, step=-1)
    ```
If indices are omitted, defaults are used (e.g., `s[:]` returns the full string).

18. **How do you check if a string is a palindrome?**  
**Answer:**  
A palindrome is a string that reads the same forward and backward (e.g., "radar"). To check:  
Reverse the string and compare it with the original.  
Use slicing for efficiency.  
Example:  
    ```python
    def is_palindrome(s):
        s = s.lower()  # Case-insensitive
        return s == s[::-1]

    print(is_palindrome("Radar"))  # True
    print(is_palindrome("hello"))  # False
    ```
This method ignores case; you can also strip spaces or special characters if needed.

19. **Explain the difference between `str.join()` and `str.format()`.**  
**Answer:**  
- `str.join()`: Combines an iterable (e.g., list) of strings into a single string, using the calling string as a separator.  
    ```python
    words = ["hello", "world"]
    print(" ".join(words))  # "hello world"
    ```
- `str.format()`: Formats a string by replacing placeholders `{}` with values.  
    ```python
    name = "Alice"
    print("Hello, {}".format(name))  # "Hello, Alice"
    ```
**Key Difference:** `join()` concatenates strings with a separator; `format()` inserts values into a template string.

20. **How do you convert a string to lowercase or uppercase?**  
**Answer:**  
Use the built-in methods `lower()` and `upper()`:  
- `lower()`: Converts all characters to lowercase.  
- `upper()`: Converts all characters to uppercase.  
Example:  
    ```python
    s = "Hello World"
    print(s.lower())  # "hello world"
    print(s.upper())  # "HELLO WORLD"
    ```
These methods return new strings (since strings are immutable) and leave the original unchanged.

21. **What is the difference between `find()` and `index()` in strings?**  
**Answer:**  
Both locate the first occurrence of a substring, but they handle failure differently:  
- `find()`: Returns the index if found, `-1` if not found.  
- `index()`: Returns the index if found, raises a `ValueError` if not found.  
Example:  
    ```python
    s = "hello"
    print(s.find("l"))    # 2 (first "l" at index 2)
    print(s.find("x"))    # -1 (not found)
    print(s.index("l"))   # 2 (first "l" at index 2)
    # print(s.index("x")) # Raises ValueError
    ```

22. **How would you remove leading and trailing whitespace from a string?**  
**Answer:**  
Use the `strip()` method to remove leading and trailing whitespace:  
- `strip()`: Removes both ends.  
- `lstrip()`: Removes leading (left).  
- `rstrip()`: Removes trailing (right).  
Example:  
    ```python
    s = "  hello world  "
    print(s.strip())   # "hello world"
    print(s.lstrip())  # "hello world  "
    print(s.rstrip())  # "  hello world"
    ```

23. **How do you count the occurrences of a substring in a string?**  
**Answer:**  
Use the `count()` method, which returns the number of non-overlapping occurrences of a substring.  
Example:  
    ```python
    s = "hello hello world"
    print(s.count("hello"))  # 2
    print(s.count("l"))      # 3
    ```
It’s case-sensitive and counts distinct occurrences.

24. **What are f-strings, and how do they compare to older string formatting methods?**  
**Answer:**  
F-strings (introduced in Python 3.6) are a concise way to embed expressions inside string literals using the `f` prefix.  
Example:  
    ```python
    name = "Alice"
    age = 25
    print(f"{name} is {age} years old")  # "Alice is 25 years old"
    ```
**Comparison:**  
- **Old `%` Operator:** `"%s is %d" % (name, age)` – Less readable, error-prone.  
- **`str.format()`:** `"{} is {}".format(name, age)` – Cleaner but verbose.  
- **F-strings:** More readable, faster (evaluated at runtime), and allow direct expressions (e.g., `f"{age + 1}"`).  
F-strings are now the preferred method.

25. **How do you split a string into a list of words?**  
**Answer:**  
Use the `split()` method, which splits a string into a list based on a delimiter (default is whitespace).  
Example:  
    ```python
    s = "hello world"
    print(s.split())      # ["hello", "world"]
    print(s.split("o"))   # ["hell", " w", "rld"] (split on "o")
    ```
Without arguments, it splits on any whitespace (spaces, tabs, newlines) and removes extra spaces.

26. **How do you remove duplicates from a list?**  
**Answer:**  
There are several ways to remove duplicates from a list:  
- **Using a Set:** Convert the list to a set and back to a list (removes order).  
    ```python
    lst = [1, 2, 2, 3, 1]
    unique_lst = list(set(lst))  # [1, 2, 3]
    ```
- **Using a Loop:** Preserve order with a seen set.  
    ```python
    lst = [1, 2, 2, 3, 1]
    seen = set()
    unique_lst = [x for x in lst if not (x in seen or seen.add(x))]
    # [1, 2, 3]
    ```
The set method is simpler and faster but doesn’t preserve order unless using Python 3.7+ (where sets maintain insertion order).

27. **What is list comprehension, and how does it work? Provide an example.**  
**Answer:**  
List comprehension is a concise way to create lists in Python using a single line of code. It combines a for loop and an optional condition inside square brackets.  
Syntax: `[expression for item in iterable if condition]`  
Example:  
    ```python
    # Square numbers from 0 to 4
    squares = [x**2 for x in range(5)]
    print(squares)  # [0, 1, 4, 9, 16]

    # Even numbers only
    evens = [x for x in range(10) if x % 2 == 0]
    print(evens)  # [0, 2, 4, 6, 8]
    ```
It’s more readable and often faster than traditional loops.

28. **How do you sort a list of dictionaries by a specific key?**  
**Answer:**  
Use the `sort()` method or `sorted()` function with the `key` parameter, typically a lambda function that specifies the dictionary key to sort by.  
Example:  
    ```python
    lst = [{"name": "Bob", "age": 25}, {"name": "Alice", "age": 30}, {"name": "Eve", "age": 20}]
    # Sort by 'age'
    sorted_lst = sorted(lst, key=lambda x: x["age"])
    print(sorted_lst)  
    # [{'name': 'Eve', 'age': 20}, {'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}]
    ```
`sorted()` returns a new list; `lst.sort()` modifies the original list.

29. **What is the difference between `append()` and `extend()` in lists?**  
**Answer:**  
- `append()`: Adds a single element to the end of the list as-is.  
- `extend()`: Adds each element of an iterable (e.g., list) individually to the end of the list.  
Example:  
    ```python
    lst = [1, 2]
    lst.append([3, 4])  # [1, 2, [3, 4]]
    print(lst)

    lst = [1, 2]
    lst.extend([3, 4])  # [1, 2, 3, 4]
    print(lst)
    ```
`append()` treats the argument as one item; `extend()` flattens the iterable.

30. **How do you merge two dictionaries in Python?**  
**Answer:**  
There are multiple ways to merge dictionaries:  
- **Using `|` (Python 3.9+):**  
    ```python
    dict1 = {"a": 1, "b": 2}
    dict2 = {"b": 3, "c": 4}
    merged = dict1 | dict2  # {"a": 1, "b": 3, "c": 4}
    ```
- **Using `update()`:** Modifies the first dictionary.  
    ```python
    dict1 = {"a": 1}
    dict2 = {"b": 2}
    dict1.update(dict2)  # {"a": 1, "b": 2}
    ```
- **Using `**` unpacking (Python 3.5+):**  
    ```python
    merged = {**dict1, **dict2}  # {"a": 1, "b": 3, "c": 4}
    ```
Later values overwrite earlier ones for duplicate keys.

31. **What is the difference between `pop()` and `remove()` in lists?**  
**Answer:**  
- `pop(index)`: Removes and returns the element at the specified index (default is last element).  
- `remove(value)`: Removes the first occurrence of the specified value (doesn’t return it).  
Example:  
    ```python
    lst = [1, 2, 3, 2]
    print(lst.pop(1))  # 2, lst = [1, 3, 2]
    lst.remove(2)      # lst = [1, 3]
    print(lst)
    ```
`pop()` is index-based; `remove()` is value-based.

32. **How do you check if a key exists in a dictionary?**  
**Answer:**  
Use the `in` operator or the `get()` method:  
- `in`: Returns `True` if the key exists.  
    ```python
    d = {"a": 1, "b": 2}
    print("a" in d)  # True
    ```
- `get()`: Returns the value if the key exists, or `None` (or a default) if not.  
    ```python
    print(d.get("c"))       # None
    print(d.get("c", 0))    # 0 (default value)
    ```
`in` is straightforward; `get()` is useful when you need a fallback.

33. **What are dictionary comprehensions? Provide an example.**  
**Answer:**  
Dictionary comprehensions are a concise way to create dictionaries using a single line, similar to list comprehensions.  
Syntax: `{key: value for item in iterable}`  
Example:  
    ```python
    # Square numbers as values
    squares = {x: x**2 for x in range(5)}
    print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

    # Filter example
    evens = {x: x**2 for x in range(10) if x % 2 == 0}
    print(evens)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
    ```
It’s efficient and readable for creating dictionaries dynamically.

34. **How do set operations like union, intersection, and difference work in Python?**  
**Answer:**  
Sets support mathematical operations:  
- **Union (`|` or `union()`)**: Combines all unique elements from both sets.  
- **Intersection (`&` or `intersection()`)**: Returns elements common to both sets.  
- **Difference (`-` or `difference()`)**: Returns elements in the first set but not the second.  
Example:  
    ```python
    set1 = {1, 2, 3}
    set2 = {2, 3, 4}
    print(set1 | set2)  # {1, 2, 3, 4} (union)
    print(set1 & set2)  # {2, 3} (intersection)
    print(set1 - set2)  # {1} (difference)
    ```
These operations are fast due to sets’ hash table implementation.

35. **How would you flatten a nested list in Python?**  
**Answer:**  
To flatten a nested list (e.g., `[[1, 2], [3, 4]]` to `[1, 2, 3, 4]`):  
- **Using List Comprehension with Nested Loop:**  
    ```python
    nested = [[1, 2], [3, 4]]
    flat = [x for sublist in nested for x in sublist]
    print(flat)  # [1, 2, 3, 4]
    ```
- **Using `itertools.chain`:**  
    ```python
    from itertools import chain
    nested = [[1, 2], [3, 4]]
    flat = list(chain(*nested))
    print(flat)  # [1, 2, 3, 4]
    ```
For deeper nesting, recursion or `itertools.chain.from_iterable()` may be needed.

36. **What is a lambda function, and when would you use it?**  
**Answer:**  
A lambda function is an anonymous, inline function defined using the `lambda` keyword. It can take any number of arguments but has a single expression.  
**Syntax:** `lambda arguments: expression`  
**Example:**  
```python
add = lambda x, y: x + y
print(add(2, 3))  # 5
```
**When to Use:**  
- Short, simple operations (e.g., sorting key: `sorted(lst, key=lambda x: x[1])`).  
- When passing a function as an argument to `map()`, `filter()`, or similar.  
- Avoid complex logic (use regular functions instead).

37. **Explain the difference between `map()`, `filter()`, and `reduce()`.**  
**Answer:**  
- `map()`: Applies a function to every item in an iterable, returning a map object (convertible to a list).  
    ```python
    lst = [1, 2, 3]
    result = map(lambda x: x**2, lst)  # Squares each element
    print(list(result))  # [1, 4, 9]
    ```
- `filter()`: Filters an iterable based on a function that returns True or False, returning a filter object.  
    ```python
    lst = [1, 2, 3, 4]
    result = filter(lambda x: x % 2 == 0, lst)  # Keeps even numbers
    print(list(result))  # [2, 4]
    ```
- `reduce()`: (From `functools`) Applies a function cumulatively to items in an iterable, reducing it to a single value.  
    ```python
    from functools import reduce
    lst = [1, 2, 3, 4]
    result = reduce(lambda x, y: x + y, lst)  # Sums all elements
    print(result)  # 10
    ```
**Key Difference:** `map()` transforms, `filter()` selects, `reduce()` aggregates.

38. **How do you define default arguments in a function?**  
**Answer:**  
Default arguments are defined in the function signature by assigning values to parameters. If the caller omits those arguments, the default values are used.  
**Example:**  
```python
def greet(name, message="Hello"):
        print(f"{message}, {name}")

greet("Alice")         # "Hello, Alice"
greet("Bob", "Hi")     # "Hi, Bob"
```
**Note:** Default arguments must follow non-default arguments in the signature.

39. **What is recursion, and how do you implement it in Python?**  
**Answer:**  
Recursion is when a function calls itself to solve a problem by breaking it into smaller subproblems. It requires a base case to stop.  
**Example (Factorial):**  
```python
def factorial(n):
        if n == 0:  # Base case
                return 1
        return n * factorial(n - 1)  # Recursive case

print(factorial(5))  # 120 (5 * 4 * 3 * 2 * 1)
```
Python has a recursion limit (default 1000) to prevent stack overflow.

40. **How does Python handle variable scope (LEGB rule)?**  
**Answer:**  
Python resolves variable scope using the LEGB rule:  
- **L (Local):** Inside the current function.  
- **E (Enclosing):** In outer functions (for nested functions).  
- **G (Global):** At the module level.  
- **B (Built-in):** Python’s built-in namespace (e.g., `len`, `print`).  
**Example:**  
```python
x = "global"
def outer():
        x = "enclosing"
        def inner():
                x = "local"
                print(x)  # "local"
        inner()
outer()
```
Python searches from innermost (L) to outermost (B) scope.

41. **What are decorators, and how do you create one?**  
**Answer:**  
Decorators are functions that modify or enhance other functions or methods. They use the `@decorator_name` syntax and wrap the target function.  
**Example:**  
```python
def my_decorator(func):
        def wrapper():
                print("Before the function")
                func()
                print("After the function")
        return wrapper

@my_decorator
def say_hello():
        print("Hello!")

say_hello()
# Output:
# Before the function
# Hello!
# After the function
```
They’re commonly used for logging, timing, or access control.

42. **How do you pass a function as an argument to another function?**  
**Answer:**  
Functions are first-class objects in Python, so you can pass them as arguments by name (without parentheses).  
**Example:**  
```python
def greet():
        print("Hello")

def call_func(func):
        func()

call_func(greet)  # "Hello"
```
This is useful in callbacks, `map()`, or event handling.

43. **What is the difference between a shallow copy and a deep copy?**  
**Answer:**  
- **Shallow Copy:** Copies the top-level structure but references nested objects. Use `copy.copy()`.  
- **Deep Copy:** Copies all levels recursively, creating independent objects. Use `copy.deepcopy()`.  
**Example:**  
```python
import copy
lst = [[1, 2], [3, 4]]
shallow = copy.copy(lst)
deep = copy.deepcopy(lst)

shallow[0][0] = 9
print(lst)      # [[9, 2], [3, 4]] (shallow affects original)
print(deep)     # [[1, 2], [3, 4]] (deep is independent)
```
Shallow is faster but risky with nested mutables.

44. **How do you handle exceptions in a function?**  
**Answer:**  
Use `try`, `except`, `else`, and `finally` blocks to handle exceptions:  
- **try:** Code that might raise an exception.  
- **except:** Catches and handles the exception.  
- **else:** Runs if no exception occurs.  
- **finally:** Always runs (cleanup).  
**Example:**  
```python
def divide(a, b):
        try:
                result = a / b
        except ZeroDivisionError:
                print("Cannot divide by zero")
        else:
                print(f"Result: {result}")
        finally:
                print("Execution complete")

divide(10, 2)  # Result: 5.0, Execution complete
divide(10, 0)  # Cannot divide by zero, Execution complete
```

45. **What is the purpose of the `global` keyword?**  
**Answer:**  
The `global` keyword allows a function to modify a variable in the global scope instead of creating a local one.  
**Example:**  
```python
x = 10
def modify():
        global x
        x = 20

modify()
print(x)  # 20
```
Without `global`, assigning to `x` inside the function would create a local variable instead.

46. **What are the key principles of OOP in Python?**  
**Answer:**  
The key principles of Object-Oriented Programming (OOP) in Python are:  
- **Encapsulation:** Bundling data (attributes) and methods into a class, restricting direct access to some components (e.g., using private attributes).  
- **Inheritance:** Allowing a class to inherit attributes and methods from another class, promoting code reuse.  
- **Polymorphism:** Enabling different classes to be treated as instances of a common superclass, with methods behaving differently based on the object.  
- **Abstraction:** Hiding complex implementation details and exposing only essential features (e.g., via abstract classes).  
Python supports these through classes, objects, and features like decorators and inheritance.

47. **What is the difference between a class and an object?**  
**Answer:**  
- **Class:** A blueprint or template that defines attributes (data) and methods (behavior) for objects. It doesn’t occupy memory until instantiated.  
- **Object:** An instance of a class, created from the class blueprint, with its own specific data.  
**Example:**  
```python
class Dog:  # Class
        def bark(self):
                print("Woof!")

dog1 = Dog()  # Object (instance of Dog)
dog1.bark()   # "Woof!"
```
The class defines the structure; the object is a concrete realization.

48. **How do you implement inheritance in Python?**  
**Answer:**  
Inheritance is implemented by defining a subclass that inherits from a parent (base) class by passing the parent class name in parentheses. The subclass inherits attributes and methods.  
**Example:**  
```python
class Animal:  # Parent class
        def speak(self):
                print("I can speak")

class Dog(Animal):  # Subclass
        def bark(self):
                print("Woof!")

dog = Dog()
dog.speak()  # "I can speak" (inherited)
dog.bark()   # "Woof!" (specific to Dog)
```
Python also supports multiple inheritance (e.g., `class Child(Parent1, Parent2)`).

49. **What is method overriding, and how does it work?**  
**Answer:**  
Method overriding occurs when a subclass provides a specific implementation of a method already defined in its parent class. The subclass version takes precedence.  
**Example:**  
```python
class Animal:
        def speak(self):
                print("Generic sound")

class Dog(Animal):
        def speak(self):  # Overrides parent method
                print("Woof!")

dog = Dog()
dog.speak()  # "Woof!" (not "Generic sound")
```
It allows customization of inherited behavior.

50. **Explain the difference between `self` and `cls` in Python.**  
**Answer:**  
- **self:** Refers to the current instance of a class in instance methods. It’s the first parameter of instance methods.  
- **cls:** Refers to the class itself in class methods. It’s the first parameter of methods decorated with `@classmethod`.  
**Example:**  
```python
class MyClass:
        class_var = "I’m a class variable"

        def instance_method(self):
                print("Instance:", self)

        @classmethod
        def class_method(cls):
                print("Class:", cls.class_var)

obj = MyClass()
obj.instance_method()  # Refers to obj
MyClass.class_method() # Refers to MyClass
```
`self` is for instance-specific data; `cls` is for class-level data.

51. **What are static methods and class methods? How do you define them?**  
**Answer:**  
- **Static Methods:** Don’t take `self` or `cls` as parameters; they’re utility functions tied to a class. Defined with `@staticmethod`.  
- **Class Methods:** Take `cls` as the first parameter and can access/modify class state. Defined with `@classmethod`.  
**Example:**  
```python
class MyClass:
        @staticmethod
        def static_func():
                print("No access to instance or class")

        @classmethod
        def class_func(cls):
                print("Access to class:", cls)

MyClass.static_func()  # "No access to instance or class"
MyClass.class_func()   # "Access to class: <class '__main__.MyClass'>"
```
Static methods are independent; class methods work with the class.

52. **What is polymorphism in Python? Provide an example.**  
**Answer:**  
Polymorphism allows different classes to be treated as instances of a common superclass, with methods behaving differently based on the object.  
**Example:**  
```python
class Cat:
        def sound(self):
                return "Meow"

class Dog:
        def sound(self):
                return "Woof"

def make_sound(animal):
        print(animal.sound())

cat = Cat()
dog = Dog()
make_sound(cat)  # "Meow"
make_sound(dog)  # "Woof"
```
The same function (`make_sound`) works with different objects, showcasing polymorphism.

53. **How do you implement encapsulation in Python?**  
**Answer:**  
Encapsulation restricts direct access to an object’s data, achieved using naming conventions:  
- **Public:** No underscore (e.g., `self.name`).  
- **Protected:** Single underscore (e.g., `self._name`) – convention, not enforced.  
- **Private:** Double underscore (e.g., `self.__name`) – name mangling.  
**Example:**  
```python
class Person:
        def __init__(self, name):
                self.__name = name  # Private

        def get_name(self):  # Public method
                return self.__name

p = Person("Alice")
print(p.get_name())    # "Alice"
# print(p.__name)      # AttributeError (mangled to _Person__name)
```
Getters/setters provide controlled access.

54. **What is the purpose of the `__init__` method?**  
**Answer:**  
The `__init__` method is a constructor in Python, automatically called when an object is created. It initializes the instance’s attributes.  
**Example:**  
```python
class Car:
        def __init__(self, brand):
                self.brand = brand  # Initialize attribute

car = Car("Toyota")
print(car.brand)  # "Toyota"
```
It sets up the object’s initial state.

55. **What are abstract base classes (ABCs), and how do you use them?**  
**Answer:**  
Abstract Base Classes (ABCs) define a blueprint for other classes, enforcing that subclasses implement specific methods. Use the `abc` module.  
**Example:**  
```python
from abc import ABC, abstractmethod

class Shape(ABC):
        @abstractmethod
        def area(self):
                pass

class Circle(Shape):
        def __init__(self, radius):
                self.radius = radius
        
        def area(self):  # Must implement
                return 3.14 * self.radius ** 2

circle = Circle(5)
print(circle.area())  # 78.5
# shape = Shape()     # TypeError: Can't instantiate abstract class
```
ABCs ensure a consistent interface across subclasses.

56. How would you implement a stack in Python?  
**Answer:**  
A stack is a LIFO (Last In, First Out) data structure. You can implement it using a Python list with `append()` for push and `pop()` for pop.  
**Example:**  
```python
class Stack:
    def __init__(self):
        self.items = []
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None
    
    def is_empty(self):
        return len(self.items) == 0

stack = Stack()
stack.push(1)
stack.push(2)
print(stack.pop())  # 2
```
Lists make it simple; `collections.deque` is an alternative for efficiency.

57. How would you implement a queue in Python?  
**Answer:**  
A queue is a FIFO (First In, First Out) data structure. Use `collections.deque` for efficient appends and pops from both ends.  
**Example:**  
```python
from collections import deque

class Queue:
    def __init__(self):
        self.items = deque()
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.popleft()
        return None
    
    def is_empty(self):
        return len(self.items) == 0

queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
print(queue.dequeue())  # 1
```
`deque` is preferred over a list for O(1) operations at both ends.

58. What is a binary search, and how do you implement it?  
**Answer:**  
Binary search finds an element in a sorted array by repeatedly dividing the search range in half. Time complexity is O(log n).  
**Example (Iterative):**  
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

arr = [1, 3, 5, 7, 9]
print(binary_search(arr, 5))  # 2
```
Requires a sorted input; returns the index or -1 if not found.

59. How do you reverse a linked list in Python?  
**Answer:**  
To reverse a linked list, adjust pointers iteratively or recursively. Here’s an iterative approach:  
**Example:**  
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def reverse_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

# Create list: 1 -> 2 -> 3
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)

# Reverse it
new_head = reverse_list(head)
while new_head:
    print(new_head.data, end=" ")  # 3 2 1
    new_head = new_head.next
```
Time complexity: O(n), space: O(1).

60. What is the time complexity of common Python list operations (e.g., append, pop, insert)?  
**Answer:**  
- `append()`: O(1) – Adds to the end (amortized).  
- `pop()`: O(1) – Removes from the end.  
- `pop(index)`: O(n) – Removes from a specific index (shifts elements).  
- `insert(index, value)`: O(n) – Inserts at an index (shifts elements).  
- `remove(value)`: O(n) – Finds and removes first occurrence (shifts elements).  
- `in` (membership test): O(n) – Linear search.  
Lists are dynamic arrays, so operations involving shifting are O(n).

61. How do you find the maximum element in a list without using `max()`?  
**Answer:**  
Iterate through the list, keeping track of the largest element seen.  
**Example:**  
```python
def find_max(lst):
    if not lst:
        return None
    max_val = lst[0]
    for num in lst:
        if num > max_val:
            max_val = num
    return max_val

lst = [3, 1, 4, 1, 5]
print(find_max(lst))  # 5
```
Time complexity: O(n), space: O(1).

62. How would you implement a hash table in Python?  
**Answer:**  
A hash table maps keys to values using a hash function. Python’s `dict` is a built-in hash table, but here’s a simple custom implementation:  
**Example:**  
```python
class HashTable:
    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]  # List of lists for chaining
    
    def _hash(self, key):
        return hash(key) % self.size
    
    def put(self, key, value):
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:  # Update if key exists
                pair[1] = value
                return
        self.table[index].append([key, value])
    
    def get(self, key):
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:
                return pair[1]
        return None

ht = HashTable()
ht.put("apple", 5)
ht.put("banana", 8)
print(ht.get("apple"))  # 5
```
Handles collisions with chaining; average time complexity is O(1).

63. What is a heap, and how can you use the `heapq` module?  
**Answer:**  
A heap is a binary tree where each parent node is less than or equal to its children (min-heap) or greater (max-heap). Python’s `heapq` provides min-heap functionality.  
**Example:**  
```python
import heapq

# Create a heap from a list
lst = [3, 1, 4, 1, 5]
heapq.heapify(lst)  # Converts to min-heap
print(lst)  # [1, 1, 4, 3, 5]

# Add element
heapq.heappush(lst, 2)
print(lst)  # [1, 1, 2, 3, 5, 4]

# Remove smallest
smallest = heapq.heappop(lst)
print(smallest)  # 1
```
Use for priority queues; operations like push/pop are O(log n).

64. How do you detect a cycle in a linked list?  
**Answer:**  
Use Floyd’s Cycle-Finding Algorithm (tortoise and hare): two pointers move at different speeds; if they meet, there’s a cycle.  
**Example:**  
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

# Create list with cycle: 1 -> 2 -> 3 -> 2
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = head.next

print(has_cycle(head))  # True
```
Time complexity: O(n), space: O(1).

65. Explain the difference between breadth-first search (BFS) and depth-first search (DFS).  
**Answer:**  
- **BFS:** Explores all nodes at the current depth before moving deeper. Uses a queue.  
  Time: O(V + E), Space: O(V) (V = vertices, E = edges).  
  Good for shortest path in unweighted graphs.
- **DFS:** Explores as far as possible along each branch before backtracking. Uses a stack (or recursion).  
  Time: O(V + E), Space: O(V).  
  Good for topological sorting or detecting cycles.

**Example (Conceptual):**  
For a tree 1 -> (2, 3), BFS visits 1, 2, 3; DFS might visit 1, 2, then 3 (or 1, 3, then 2).

66. How do you read a file line by line in Python?  
**Answer:**  
You can read a file line by line using a `for` loop with an open file object, which iterates over lines efficiently.  
**Example:**  
```python
with open("file.txt", "r") as file:
    for line in file:
        print(line.strip())  # strip() removes trailing newlines
```
This is memory-efficient as it doesn’t load the entire file into memory at once.

67. What is the difference between `read()`, `readline()`, and `readlines()`?  
**Answer:**  
- `read()`: Reads the entire file content into a single string.  
  ```python
  with open("file.txt", "r") as file:
      content = file.read()
  ```
- `readline()`: Reads one line at a time (up to the next newline).  
  ```python
  with open("file.txt", "r") as file:
      line = file.readline()  # First line only
  ```
- `readlines()`: Reads all lines into a list of strings (each line is an element).  
  ```python
  with open("file.txt", "r") as file:
      lines = file.readlines()  # ["line1\n", "line2\n"]
  ```
Key Difference: `read()` is all at once, `readline()` is one line, `readlines()` is a list of lines.

68. How do you write to a file in Python?  
**Answer:**  
Use `open()` with mode "w" (write, overwrites file) or "a" (append), and the `write()` method.  
**Example:**  
```python
with open("file.txt", "w") as file:
    file.write("Hello, world!\n")
    file.write("Another line")
```
"w": Creates a new file or overwrites an existing one.  
Use `writelines()` for a list of strings (no automatic newlines).

69. What is the purpose of the `with` statement when working with files?  
**Answer:**  
The `with` statement ensures proper resource management by automatically closing the file after operations, even if an error occurs. It’s a context manager.  
**Example:**  
```python
with open("file.txt", "r") as file:
    content = file.read()
# File is automatically closed here
```
Without `with`, you’d need `file.close()` manually, risking resource leaks.

70. How do you append data to an existing file?  
**Answer:**  
Open the file in append mode ("a") and use `write()` to add data at the end.  
**Example:**  
```python
with open("file.txt", "a") as file:
    file.write("Appending this line\n")
```
Unlike "w", "a" doesn’t overwrite existing content; it adds to the end.

71. How do you handle file exceptions (e.g., `FileNotFoundError`)?  
**Answer:**  
Use `try` and `except` to catch exceptions like `FileNotFoundError` or `IOError`.  
**Example:**  
```python
try:
    with open("nonexistent.txt", "r") as file:
        content = file.read()
except FileNotFoundError:
    print("File not found!")
except IOError:
    print("An I/O error occurred")
```
This prevents the program from crashing and allows graceful error handling.

72. How do you read and write CSV files in Python?  
**Answer:**  
Use the `csv` module:  
- **Reading:** Use `csv.reader` or `csv.DictReader`.  
- **Writing:** Use `csv.writer` or `csv.DictWriter`.  
**Example:**  
```python
import csv

# Writing
with open("data.csv", "w", newline="") as file:
    writer = csv.writer(file)
    writer.writerow(["Name", "Age"])
    writer.writerow(["Alice", 25])

# Reading
with open("data.csv", "r") as file:
    reader = csv.reader(file)
    for row in reader:
        print(row)  # ['Name', 'Age'], ['Alice', '25']
```
`newline=""` ensures consistent line endings across platforms.

73. How do you work with JSON files in Python?  
**Answer:**  
Use the `json` module:  
- **Reading:** `json.load()` (file) or `json.loads()` (string).  
- **Writing:** `json.dump()` (file) or `json.dumps()` (string).  
**Example:**  
```python
import json

# Writing
data = {"name": "Alice", "age": 25}
with open("data.json", "w") as file:
    json.dump(data, file)

# Reading
with open("data.json", "r") as file:
    loaded_data = json.load(file)
    print(loaded_data)  # {'name': 'Alice', 'age': 25}
```
JSON is great for structured data exchange.

74. What is the difference between binary and text file modes?  
**Answer:**  
- **Text Mode** (e.g., "r", "w"): Reads/writes data as strings, with automatic encoding/decoding (e.g., UTF-8). Default mode.  
  ```python
  with open("file.txt", "w") as file:
      file.write("Hello")  # String
  ```
- **Binary Mode** (e.g., "rb", "wb"): Reads/writes raw bytes, no encoding/decoding. Used for non-text files (e.g., images).  
  ```python
  with open("file.bin", "wb") as file:
      file.write(b"Hello")  # Bytes
  ```
Text mode handles line endings; binary mode is exact.

75. How do you delete a file using Python?  
**Answer:**  
Use `os.remove()` from the `os` module to delete a file.  
**Example:**  
```python
import os

file_path = "file.txt"
if os.path.exists(file_path):
    os.remove(file_path)
    print("File deleted")
else:
    print("File not found")
```
Check existence with `os.path.exists()` to avoid errors; `os.unlink()` is a synonym.

76. **What is the difference between `import module` and `from module import *`?**  
**Answer:**  
- `import module`: Imports the entire module, and you access its contents with dot notation (e.g., `module.function()`).  
    ```python
    import math
    print(math.sqrt(16))  # 4.0
    ```
- `from module import *`: Imports all public names (variables, functions, etc.) from the module into the current namespace, so you can use them directly.  
    ```python
    from math import *
    print(sqrt(16))  # 4.0
    ```
- **Key Difference:** `import module` is safer and avoids namespace pollution; `from module import *` is convenient but risks name conflicts.

77. **How do you install a third-party library using pip?**  
**Answer:**  
Use `pip`, Python’s package manager, from the command line:  
- Install a library: `pip install library_name`  
    ```bash
    pip install requests
    ```
- Specific version: `pip install library_name==version`  
    ```bash
    pip install requests==2.28.1
    ```
- Upgrade: `pip install --upgrade library_name`  
    ```bash
    pip install --upgrade requests
    ```
Run in a terminal; ensure `pip` matches your Python version (e.g., `pip3` for Python 3).

78. **What is the purpose of the `sys` module?**  
**Answer:**  
The `sys` module provides access to system-specific parameters and functions, interacting with the Python interpreter.  
Examples:  
- `sys.argv`: List of command-line arguments.  
    ```python
    import sys
    print(sys.argv)  # ['script.py', 'arg1', 'arg2']
    ```
- `sys.exit()`: Exits the program.  
    ```python
    sys.exit(0)  # 0 = success
    ```
- `sys.path`: List of directories Python searches for modules.  
It’s useful for scripting and runtime control.

79. **How do you generate random numbers using the `random` module?**  
**Answer:**  
The `random` module provides functions for generating pseudo-random numbers.  
Example:  
    ```python
    import random

    print(random.randint(1, 10))    # Random int between 1 and 10 (inclusive)
    print(random.random())          # Random float between 0.0 and 1.0
    print(random.choice([1, 2, 3])) # Random element from a sequence
    random.shuffle([1, 2, 3])       # Shuffles list in place
    ```
Use `random.seed()` for reproducible results.

80. **What is the `datetime` module, and how do you use it?**  
**Answer:**  
The `datetime` module handles dates and times in Python, providing classes like `datetime`, `date`, and `timedelta`.  
Example:  
    ```python
    from datetime import datetime, timedelta

    # Current date and time
    now = datetime.now()
    print(now)  # e.g., 2025-03-24 12:00:00

    # Add 2 days
    future = now + timedelta(days=2)
    print(future)

    # Format date
    print(now.strftime("%Y-%m-%d"))  # "2025-03-24"
    ```
It’s used for date arithmetic and formatting.

81. **How do you use the `os` module to interact with the operating system?**  
**Answer:**  
The `os` module provides functions to interact with the operating system, like file operations and directory management.  
Example:  
    ```python
    import os

    print(os.getcwd())          # Current working directory
    os.mkdir("new_folder")      # Create a directory
    os.remove("file.txt")       # Delete a file
    print(os.listdir("."))      # List directory contents
    print(os.path.join("dir", "file.txt"))  # "dir/file.txt" (path joining)
    ```
It’s platform-independent for file and system tasks.

82. **What is `numpy`, and how does it differ from Python lists?**  
**Answer:**  
NumPy is a library for numerical computing, providing a powerful `ndarray` (n-dimensional array) object.  
Differences from Lists:  
- **Performance:** NumPy arrays are faster due to fixed-type, contiguous memory.  
- **Functionality:** Supports vectorized operations (e.g., element-wise addition).  
- **Homogeneous:** All elements must be the same type (unlike lists).  
Example:  
    ```python
    import numpy as np

    arr = np.array([1, 2, 3])
    print(arr + 2)  # [3, 4, 5] (vectorized)
    lst = [1, 2, 3]
    # lst + 2  # TypeError with lists
    ```
NumPy is ideal for scientific computing.

83. **How do you create a virtual environment in Python?**  
**Answer:**  
A virtual environment isolates Python dependencies for a project. Use the `venv` module:  
Steps:  
    ```bash
    # Create virtual environment
    python -m venv myenv

    # Activate (Windows)
    myenv\Scripts\activate

    # Activate (Linux/Mac)
    source myenv/bin/activate

    # Deactivate
    deactivate
    ```
Once activated, `pip install` installs packages locally in `myenv`, avoiding global conflicts.

84. **What is the purpose of the `collections` module?**  
**Answer:**  
The `collections` module provides specialized container data types beyond built-ins like lists and dicts.  
Examples:  
- **Counter:** Counts occurrences of elements.  
    ```python
    from collections import Counter
    print(Counter("hello"))  # Counter({'l': 2, 'h': 1, 'e': 1, 'o': 1})
    ```
- **deque:** Double-ended queue for fast appends/pops.  
- **defaultdict:** Dictionary with default values for missing keys.  
It enhances functionality for specific use cases.

85. **How do you use the `re` module for regular expressions?**  
**Answer:**  
The `re` module handles pattern matching and text manipulation using regular expressions.  
Example:  
    ```python
    import re

    text = "Contact: 123-456-7890"
    # Search for pattern
    match = re.search(r"\d{3}-\d{3}-\d{4}", text)
    print(match.group())  # "123-456-7890"

    # Replace
    new_text = re.sub(r"\d", "X", text)
    print(new_text)  # "Contact: XXX-XXX-XXXX"

    # Find all matches
    numbers = re.findall(r"\d+", text)
    print(numbers)  # ["123", "456", "7890"]
    ```
Use `search()`, `match()`, `findall()`, or `sub()` for pattern operations.

86. **What is exception handling, and why is it important?**  
**Answer:**  
Exception handling is the process of managing errors (exceptions) that occur during program execution, preventing crashes. It uses constructs like `try` and `except` to catch and respond to issues.  
**Why Important:**  
- Prevents program termination due to unexpected errors.  
- Improves robustness and user experience.  
- Allows graceful recovery or logging of issues (e.g., file not found).  
Without it, unhandled exceptions stop execution abruptly.

87. **How do you use `try`, `except`, `else`, and `finally` blocks?**  
**Answer:**  
- `try`: Contains code that might raise an exception.  
- `except`: Catches and handles specific exceptions.  
- `else`: Runs if no exception occurs in `try`.  
- `finally`: Always executes, regardless of exceptions (e.g., cleanup).  
Example:  
    ```python
    try:
            result = 10 / 2
    except ZeroDivisionError:
            print("Division by zero!")
    else:
            print(f"Result: {result}")
    finally:
            print("Done")
    # Output: Result: 5.0, Done
    ```
It structures error handling logically.

88. **How do you raise a custom exception in Python?**  
**Answer:**  
Use the `raise` keyword, optionally creating a custom exception class by inheriting from `Exception`.  
Example:  
    ```python
    class MyError(Exception):
            pass

    def check_positive(num):
            if num < 0:
                    raise MyError("Number must be positive!")
            return num

    try:
            check_positive(-5)
    except MyError as e:
            print(e)  # "Number must be positive!"
    ```
Custom exceptions improve code specificity.

89. **What is the difference between an error and an exception?**  
**Answer:**  
- **Error:** A broad term for anything that goes wrong (e.g., syntax errors, logical errors). Some are unrecoverable (e.g., `SyntaxError`).  
- **Exception:** A specific type of error during runtime that can be caught and handled (e.g., `ZeroDivisionError`, `FileNotFoundError`).  
Example:  
    ```python
    print(1/0)  # ZeroDivisionError (exception, catchable).
    if True print("hi")  # SyntaxError (error, not catchable).
    ```
Exceptions are manageable; many errors aren’t.

90. **How do you catch multiple exceptions in a single `except` block?**  
**Answer:**  
List multiple exceptions in a tuple within a single `except` clause.  
Example:  
    ```python
    try:
            num = int(input("Enter a number: "))
            result = 10 / num
    except (ValueError, ZeroDivisionError) as e:
            print(f"Error: {e}")
    ```
- `ValueError`: If input isn’t an integer.  
- `ZeroDivisionError`: If `num` is 0.  
This reduces repetitive code.

91. **What happens if an exception is not handled?**  
**Answer:**  
If an exception isn’t handled, Python propagates it up the call stack. If it reaches the top without a handler, the program terminates, displaying a traceback with the exception type and message.  
Example:  
    ```python
    def divide(a, b):
            return a / b

    print(divide(10, 0))  # ZeroDivisionError: division by zero
    # Program stops with traceback
    ```
Unhandled exceptions crash the program.

92. **How do you log exceptions using the `logging` module?**  
**Answer:**  
Use the `logging` module to record exceptions instead of printing them, with levels like `DEBUG`, `INFO`, or `ERROR`.  
Example:  
    ```python
    import logging

    logging.basicConfig(filename="app.log", level=logging.ERROR)
    try:
            result = 10 / 0
    except ZeroDivisionError as e:
            logging.error("An error occurred", exc_info=True)
    ```
`exc_info=True` logs the full traceback.  
Output goes to `app.log` for later analysis, improving debugging.

93. **What is the purpose of the `assert` statement?**  
**Answer:**  
The `assert` statement tests a condition; if False, it raises an `AssertionError` with an optional message. It’s used for debugging or enforcing invariants.  
Example:  
    ```python
    x = -1
    assert x >= 0, "x must be non-negative"
    # Raises AssertionError: x must be non-negative
    ```
Disabled in production with `-O` flag (`python -O script.py`).

94. **How do you handle a `KeyError` in a dictionary?**  
**Answer:**  
Catch a `KeyError` with `try/except`, or use `get()` to avoid it by providing a default value.  
Example:  
    ```python
    d = {"a": 1}
    # Using try/except
    try:
            print(d["b"])
    except KeyError:
            print("Key not found")

    # Using get()
    print(d.get("b", 0))  # 0 (default if "b" not found)
    ```
`get()` is simpler for optional keys; `try` suits complex logic.

95. **What is the difference between `sys.exit()` and raising an exception?**  
**Answer:**  
- `sys.exit()`: Terminates the program immediately with an exit code (e.g., 0 for success, non-zero for failure). From `sys` module.  
    ```python
    import sys
    sys.exit(1)  # Exits with code 1
    ```
- Raising an Exception: Throws an error that can be caught and handled; doesn’t necessarily stop the program unless unhandled.  
    ```python
    raise ValueError("Something went wrong")
    ```
**Key Difference:** `sys.exit()` is a hard stop; exceptions allow recovery if caught.

96. **What are generators, and how do they differ from regular functions?**
Answer:
Generators are functions that produce a sequence of values lazily, one at a time, using `yield`. Unlike regular functions:  
- **Regular Functions**: Return a single value (or list) and exit.  
- **Generators**: Yield values iteratively, maintaining state between calls, and are memory-efficient for large datasets.

Example:
```python
def regular_func():
    return [1, 2, 3]  # All at once

def generator_func():
    for i in [1, 2, 3]:
        yield i  # One at a time

gen = generator_func()
print(next(gen))  # 1
print(next(gen))  # 2
```
Generators save memory by not storing the entire sequence.

97. **How do you create a generator using the yield keyword?**
Answer:
Use `yield` in a function to return a value and pause execution, resuming on the next `next()` call.

Example:
```python
def count_up_to(n):
    i = 0
    while i < n:
        yield i
        i += 1

gen = count_up_to(3)
for num in gen:
    print(num)  # 0, 1, 2
```
Each `yield` produces a value; the function’s state is preserved between yields.

98. **What is a context manager, and how do you implement one?**
Answer:
A context manager manages resources (e.g., files) by defining setup and teardown logic, typically used with the `with` statement.  
Implementation: Use `__enter__` (setup) and `__exit__` (teardown) methods.

Example:
```python
class MyContext:
    def __enter__(self):
        print("Entering")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        print("Exiting")

with MyContext() as ctx:
    print("Inside")
# Output: Entering, Inside, Exiting
```
The `with` statement ensures `__exit__` runs, even if an error occurs.

99. **What are metaclasses in Python?**
Answer:
Metaclasses are classes of classes—they define how classes are created. The default metaclass is `type`. Use them to customize class creation.

Example:
```python
class MyMeta(type):
    def __new__(cls, name, bases, dct):
        print(f"Creating class {name}")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=MyMeta):
    pass
# Output: Creating class MyClass
```
Metaclasses are advanced and used for frameworks (e.g., ORMs).

100. **How does multithreading work in Python with the GIL (Global Interpreter Lock)?**
Answer:
Multithreading in Python uses the `threading` module to run multiple threads, but the GIL (in CPython) prevents true parallelism for CPU-bound tasks.  
- **GIL**: A mutex that allows only one thread to execute Python bytecode at a time.  
- **Impact**: I/O-bound tasks (e.g., network calls) benefit from threading; CPU-bound tasks don’t due to GIL.

Example:
```python
import threading

def task():
    print("Running")

t = threading.Thread(target=task)
t.start()
t.join()
```
Use `multiprocessing` for CPU-bound parallelism.

101. **What is the difference between multiprocessing and multithreading?**
Answer:
- **Multithreading**: Multiple threads within one process share memory. Limited by GIL for CPU tasks in CPython. Good for I/O-bound work.  
- **Multiprocessing**: Multiple processes with separate memory spaces. Bypasses GIL, ideal for CPU-bound tasks.

Example:
```python
from multiprocessing import Process

def task():
    print("Running")

p = Process(target=task)
p.start()
p.join()
```
Key Difference: Threads share memory; processes don’t, avoiding GIL.

102. **How do you use the asyncio library for asynchronous programming?**
Answer:
`asyncio` enables asynchronous I/O using coroutines with `async` and `await`.

Example:
```python
import asyncio

async def say_hello():
    print("Hello")
    await asyncio.sleep(1)  # Simulate I/O
    print("World")

asyncio.run(say_hello())
# Output: Hello, (1s pause), World
```
Use `asyncio.run()` to execute coroutines; it’s great for concurrent I/O tasks.

103. **What are closures, and how do they work in Python?**
Answer:
A closure is a nested function that captures and remembers variables from its enclosing scope, even after the outer function finishes.

Example:
```python
def outer(x):
    def inner(y):
        return x + y  # x is "closed over"
    return inner

add_five = outer(5)
print(add_five(3))  # 8
```
The inner function retains access to `x` via closure.

104. **How do you profile a Python program for performance?**
Answer:
Use the `cProfile` module to measure execution time and identify bottlenecks.

Example:
```python
import cProfile

def slow_func():
    total = 0
    for i in range(1000000):
        total += i
    return total

cProfile.run("slow_func()")
```
Output shows time per function call. Use `time` module for simpler timing or third-party tools like `line_profiler` for line-by-line analysis.

105. **What is the difference between `__str__` and `__repr__`?**
Answer:
- `__str__`: Returns a human-readable string representation (for end users). Called by `str()` and `print()`.  
- `__repr__`: Returns an unambiguous string representation (for developers/debugging). Called by `repr()`.

Example:
```python
class Point:
    def __init__(self, x, y):
        self.x, self.y = x, y
    
    def __str__(self):
        return f"Point({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

p = Point(1, 2)
print(str(p))   # Point(1, 2)
print(repr(p))  # Point(x=1, y=2)
```
`__str__` is informal; `__repr__` aims for precision.

106. **Write a Python program to find the factorial of a number.**
Answer:
Factorial of a number `n` (n!) is the product of all positive integers up to `n`.

Code:
```python
def factorial(n):
    if n < 0:
        return "Factorial not defined for negative numbers"
    elif n == 0:
        return 1
    else:
        result = 1
        for i in range(1, n + 1):
            result *= i
        return result

# Test
print(factorial(5))  # 120 (5 * 4 * 3 * 2 * 1)
print(factorial(0))  # 1
```
Explanation: Uses iteration for simplicity; recursion (`n * factorial(n-1)`) is also valid but less efficient for large `n`.

107. **Write a function to check if a number is prime.**
Answer:
A prime number is greater than 1 and divisible only by 1 and itself.

Code:
```python
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

# Test
print(is_prime(7))   # True
print(is_prime(12))  # False
```
Explanation: Checks divisibility up to the square root for efficiency; O(√n) time complexity.

108. **Implement a function to find the Fibonacci sequence up to n terms.**
Answer:
The Fibonacci sequence starts with 0, 1, and each subsequent number is the sum of the previous two.

Code:
```python
def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[-1] + fib[-2])
    return fib

# Test
print(fibonacci(6))  # [0, 1, 1, 2, 3, 5]
```
Explanation: Builds the sequence iteratively; O(n) time complexity.

109. **Write a program to find the second largest number in a list.**
Answer:
Track the largest and second largest numbers in a single pass.

Code:
```python
def second_largest(lst):
    if len(lst) < 2:
        return None
    largest = second = float('-inf')
    for num in lst:
        if num > largest:
            second = largest
            largest = num
        elif num > second and num != largest:
            second = num
    return second if second != float('-inf') else None

# Test
print(second_largest([3, 1, 4, 1, 5]))  # 4
print(second_largest([1]))             # None
```
Explanation: O(n) time; handles duplicates by checking `num != largest`.

110. **How would you merge two sorted lists into a single sorted list?**
Answer:
Use a two-pointer approach to compare and merge elements.

Code:
```python
def merge_sorted_lists(list1, list2):
    merged = []
    i, j = 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            merged.append(list1[i])
            i += 1
        else:
            merged.append(list2[j])
            j += 1
    merged.extend(list1[i:])  # Add remaining elements
    merged.extend(list2[j:])
    return merged

# Test
print(merge_sorted_lists([1, 3, 5], [2, 4, 6]))  # [1, 2, 3, 4, 5, 6]
```
Explanation: O(n + m) time, where n and m are list lengths.

111. **Write a function to remove all vowels from a string.**
Answer:
Filter out vowels (a, e, i, o, u, case-insensitive) from the string.

Code:
```python
def remove_vowels(s):
    vowels = set("aeiouAEIOU")
    return "".join(char for char in s if char not in vowels)

# Test
print(remove_vowels("Hello World"))  # "Hll Wrld"
```
Explanation: Uses a set for O(1) lookups; O(n) time, where n is string length.

112. **Implement a binary search tree in Python.**
Answer:
A Binary Search Tree (BST) has nodes where left child < node < right child.

Code:
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        if not self.root:
            self.root = Node(value)
        else:
            self._insert_rec(self.root, value)
    
    def _insert_rec(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = Node(value)
            else:
                self._insert_rec(node.left, value)
        else:
            if node.right is None:
                node.right = Node(value)
            else:
                self._insert_rec(node.right, value)

# Test
bst = BST()
bst.insert(5)
bst.insert(3)
bst.insert(7)
```
Explanation: Recursive insertion; average O(log n) time for balanced BST.

113. **Write a program to find all anagrams in a list of strings.**
Answer:
Group strings that are anagrams (same characters, different order) using sorted characters as keys.

Code:
```python
def find_anagrams(strings):
    anagram_dict = {}
    for s in strings:
        key = "".join(sorted(s))
        anagram_dict.setdefault(key, []).append(s)
    return [group for group in anagram_dict.values() if len(group) > 1]

# Test
print(find_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"]))
# [['eat', 'tea', 'ate'], ['tan', 'nat']]
```
Explanation: O(n * k * log k) time, where n is list length, k is max string length.

114. **How do you find the longest common substring between two strings?**
Answer:
Use dynamic programming to track common substrings.

Code:
```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_idx = 0
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_idx = i
    return s1[end_idx - max_len:end_idx]

# Test
print(longest_common_substring("ABCD", "ABED"))  # "AB"
```
Explanation: O(m * n) time and space; returns the longest common substring.

115. **Write a function to rotate a list by k positions.**
Answer:
Shift elements right by k positions, wrapping around.

Code:
```python
def rotate_list(lst, k):
    if not lst:
        return lst
    k = k % len(lst)  # Normalize k
    return lst[-k:] + lst[:-k]

# Test
print(rotate_list([1, 2, 3, 4, 5], 2))  # [4, 5, 1, 2, 3]
```
Explanation: Uses slicing; O(n) time, O(n) space. Modulo handles k > len(lst).

116. **How would you optimize a Python script that processes large datasets?**

**Answer:**
To optimize a Python script for large datasets:
- **Use Generators:** Process data lazily (e.g., `yield`) to reduce memory usage.
- **Leverage Libraries:** Use `pandas` or `numpy` for efficient data handling.
- **Avoid Loops:** Replace with vectorized operations (e.g., `numpy` arrays).
- **Profile First:** Use `cProfile` to identify bottlenecks.
- **Chunking:** Process data in smaller batches (e.g., `pandas.read_csv(chunksize=1000)`).
- **Multiprocessing:** Parallelize tasks for CPU-bound work.

**Example:**
```python
import pandas as pd

def process_large_file(file_path):
    for chunk in pd.read_csv(file_path, chunksize=1000):
        # Process chunk
        print(chunk.sum())
```

117. **How do you debug a Python program effectively?**

**Answer:**
- **Print Statements:** Quick way to inspect variables (e.g., `print(var)`).
- **pdb:** Use Python’s debugger (`import pdb; pdb.set_trace()`) to step through code.
- **IDE Tools:** Use PyCharm/VS Code breakpoints and variable watches.
- **Logging:** Replace prints with logging for persistent output.
- **Unit Tests:** Isolate issues with small test cases.

**Example (pdb):**
```python
def buggy_func(x):
    y = x / 0  # Bug
    return y

import pdb; pdb.set_trace()
buggy_func(5)  # Step through with 'n' (next), 'p y' (print y)
```

118. **What steps would you take to handle memory leaks in Python?**

**Answer:**
Python uses garbage collection, but leaks can occur with circular references or resource mismanagement:
- **Profile Memory:** Use `tracemalloc` to track allocations.
- **Check References:** Avoid circular references (use `weakref` if needed).
- **Close Resources:** Ensure files, sockets, etc., are closed (use `with`).
- **Enable GC Debugging:** `import gc; gc.set_debug(gc.DEBUG_LEAK)` to detect uncollected objects.
- **Optimize Data Structures:** Use generators or streams for large data.

**Example (tracemalloc):**
```python
import tracemalloc

tracemalloc.start()
# Code to monitor
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics("lineno")
print(top_stats[:5])
```

119. **How would you design a simple REST API using Python (e.g., with Flask)?**

**Answer:**
Use Flask to create endpoints for CRUD operations:
- **Setup:** Install Flask (`pip install flask`).
- **Define Routes:** Use `@app.route` for GET, POST, etc.
- **Return JSON:** Use `jsonify` for responses.

**Example:**
```python
from flask import Flask, jsonify, request

app = Flask(__name__)

data = []

@app.route('/items', methods=['GET'])
def get_items():
    return jsonify(data)

@app.route('/items', methods=['POST'])
def add_item():
    item = request.json
    data.append(item)
    return jsonify(item), 201

if __name__ == '__main__':
    app.run(debug=True)
```
Run with `python script.py`; test with curl or Postman.

120. **How do you unit test Python code using unittest or pytest?**

**Answer:**
- **unittest:** Built-in, uses test classes and assertions.
- **pytest:** Third-party, simpler syntax, auto-discovers tests.

**Example (unittest):**
```python
import unittest

def add(a, b):
    return a + b

class TestMath(unittest.TestCase):
    def test_add(self):
        self.assertEqual(add(2, 3), 5)

if __name__ == '__main__':
    unittest.main()
```

**Example (pytest):**
```python
# test_math.py
def add(a, b):
    return a + b

def test_add():
    assert add(2, 3) == 5
# Run: pytest test_math.py
```
pytest is preferred for its simplicity and plugins.

121. **How would you process a large CSV file without loading it entirely into memory?**

**Answer:**
Use `csv` module with a for loop or `pandas` with chunking:

**Example (csv):**
```python
import csv

with open('large.csv', 'r') as file:
    reader = csv.reader(file)
    next(reader)  # Skip header
    for row in reader:
        print(row)  # Process row-by-row
```

**Example (pandas):**
```python
import pandas as pd

for chunk in pd.read_csv('large.csv', chunksize=1000):
    print(chunk.sum())  # Process chunk
```
Both methods stream data, keeping memory usage low.

122. **How do you handle concurrency in a Python web application?**

**Answer:**
- **Threading:** Use threading or a web framework’s thread pool (e.g., Flask with `gunicorn --threads`). Good for I/O-bound tasks.
- **Asyncio:** Use `asyncio` with `aiohttp` or `FastAPI` for async I/O.
- **Multiprocessing:** Use multiprocessing or `gunicorn --workers` for CPU-bound tasks, bypassing GIL.
- **Task Queues:** Use `celery` with a broker (e.g., Redis) for background tasks.

**Example (gunicorn):**
```bash
gunicorn -w 4 app:app  # 4 worker processes
```

123. **What approach would you take to scrape a website using Python?**

**Answer:**
Use `requests` to fetch HTML and `BeautifulSoup` to parse it:

**Steps:**
- Send HTTP request.
- Parse HTML.
- Extract data.
- Handle delays (e.g., `time.sleep`) to respect `robots.txt`.

**Example:**
```python
import requests
from bs4 import BeautifulSoup

url = "http://example.com"
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')
titles = soup.find_all('h1')
for title in titles:
    print(title.text)
```
Use `selenium` for dynamic sites with JavaScript.

124. **How would you implement a simple caching mechanism in Python?**

**Answer:**
Use a dictionary or `functools.lru_cache` for memoization:

**Example (dict):**
```python
cache = {}

def expensive_function(x):
    if x not in cache:
        cache[x] = x * x  # Simulate computation
    return cache[x]

print(expensive_function(5))  # Computes: 25
print(expensive_function(5))  # Cached: 25
```

**Example (lru_cache):**
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(10))  # Cached results
```
`lru_cache` is built-in and handles eviction.

125. **How do you deploy a Python application to production?**

**Answer:**
- **Package:** Use `pyproject.toml` or `setup.py` for dependencies.
- **Server:** Deploy with `gunicorn` (e.g., `gunicorn app:app`) behind Nginx.
- **Environment:** Use a `virtualenv` or Docker container.
- **CI/CD:** Automate with GitHub Actions or Jenkins.
- **Monitoring:** Add logging and tools like Sentry.

**Example (Docker):**
```Dockerfile
FROM python:3.9
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "app:app"]
```
Build and run: `docker build -t myapp . && docker run -p 8000:8000 myapp`.